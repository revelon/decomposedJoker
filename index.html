<!doctype html>
<html lang="cs">
<head>
	<meta charset="utf-8">
	<title>Decomposed Joker GUI</title>
	<link rel="icon" type="image/png" href="favicon.ashx">
	<style>
		div#guiHand div div, div#guiNewSets div div, div#guiTable div div { width: 36px; display: inline-block; cursor: pointer;}
		div {border: 2px dotted blue; margin: 4px; padding: 4px; }
		div.active {border: 2px solid DarkGreen; filter: drop-shadow(4px 4px 5px DarkGreen); }
		div.spades {background-color: LightSteelBlue;}
		div.clubs {background-color: LightGray;}
		div.hearts {background-color: LightSalmon;}
		div.diamonds {background-color: LightCoral;}
		div.wildcard {background-color: Tan;}
	</style>
	<script>
		"use strict";

		// https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
		// Example POST method implementation:
		async function postData(data = {}) {
			// Default options are marked with *
			const response = await fetch('api.php', {
				method: 'POST', // *GET, POST, PUT, DELETE, etc.
				mode: 'cors', // no-cors, *cors, same-origin
				cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
				credentials: 'same-origin', // include, *same-origin, omit
				headers: {
					'Content-Type': 'application/json'
					// 'Content-Type': 'application/x-www-form-urlencoded',
				},
				redirect: 'follow', // manual, *follow, error
				referrerPolicy: 'no-referrer', // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url
				body: JSON.stringify(data) // body data type must match "Content-Type" header
			});
			const ret = await response.json(); // parses JSON response into native JavaScript objects
			console.dir('server call returned debug:', ret.dbg);
			if (response.status > 399) {
				throw "Server responded error with: " + ret.message;
			} else {
				return ret.data;
			}
		}

		var allCards = {};
		var playerId = '';
		var hand = [];
		var sets = [];
		var table = [];
		var actives = [];
		var guiHand;
		var guiNewSets;
		var guiTable;

		async function initGame() {
			console.log('method: initGame');
			try {
				const deck = await postData({ action: 'initGame' });
				deck.forEach(c => window.allCards[c.id] = c);
				//console.dir('initGame', window.allCards);
			} catch (err) {
				console.dir('err', err);
			}

			let hand = {};
			hand.id = 0; // 0 special setId and is always player's hand
			hand.cards = [];
			window.hand.push(hand);

			guiHand = document.getElementById('guiHand');
			guiHand.innerHTML = '';
			guiNewSets = document.getElementById('guiNewSets');
			guiNewSets.innerHTML = '';			
			guiTable = document.getElementById('guiTable');
			guiTable.innerHTML = '';

			createEmptySet();
		}

		async function registerPlayer(name) {
			console.log('method: registerPlayer', name);
			try {
				window.playerId = await postData({ action: 'registerPlayer', 'name': name });
				console.dir('registerPlayer', window.playerId);
			} catch (err) {
				console.dir('err', err);
			}
		}

		async function getHand(render = false) {
			console.log('method: getHand');
			try {
				window.hand[0].cards = await postData({ action: 'getHand', 'playerId': window.playerId });
				console.dir('getHand', window.hand);
			} catch (err) {
				console.dir('err', err);
			}
			if (render) {
				renderCardGroups(window.hand, guiHand);
			}
		}

		async function getCard(render = false) {
			console.log('method: getCard');
			try {
				window.hand[0].cards = await postData({ action: 'getCard', 'playerId': window.playerId });
				console.dir('getCard', window.hand);
			} catch (err) {
				console.dir('err', err);
			}
			if (render) {
				renderCardGroups(window.hand, guiHand);
			}
			showTurnEnd();
		}

		async function getTable(render = false) {
			console.log('method: getTable');
			try {
				const tbl = await postData({ action: 'getTable', 'playerId': window.playerId });
				window.table = [];
				tbl.forEach( grp => {
					let set = {};
					set.id = "s" + Math.random().toString(12).substring(2, 8);
					set.cards = grp;
					window.table.push(set);
				});
				console.dir('getTable', window.table);
			} catch (err) {
				console.dir('err', err);
			}
			if (render) {
				renderCardGroups(window.table, guiTable);
			}
		}

		async function getServerState() {
			console.log('method: getServerState');
			await getHand(true);
			await getTable(true);
			window.actives = [];
			window.sets = [];
			createEmptySet();
			renderCardGroups(window.sets, guiNewSets);
		}

		async function validateAndDoTurn() {
			console.log('method: validateAndDoTurn');
			// iterate through all new groups
			/*
			window.sets.forEach( async (grp, idx) => {
				console.log('validating group_id...', idx, grp.id);
				let cards = [];
				window.sets[idx].cards.forEach( c => {
					cards.push({id: c, type: window.allCards[c].type, value: window.allCards[c].value}) 
				} );
				const valid = await validateGroup(cards);
				if (valid) {
					console.log('great, valid set id:', grp.id);
					getServerState();
				} else {
					console.log('bad luck, invalid set id:', grp.id);
					return false;
				}
			} );

			// iterate through modified table  !!!! predelat na bezne pole (asi) !!
			for(const s in window.table) {
				console.log('iterating through table, group_id...', s, window.table[s].id);
				let cards = [];
				window.table[s].cards.forEach( c => cards.push({id: c, type: window.allCards[c].type, value: window.allCards[c].value}) );
				if (await validateGroup(cards)) {
					console.log('great, valid set id:', s);
				} else {
					console.log('bad luck, invalid set id:', s);
					return false;
				}
			}*/

			try {
				let newTbl = [];
				for(const s in window.table) {
					newTbl.push(window.table[s]);
				}
				for(const s in window.sets) {
					newTbl.push(window.sets[s]);
				}
				console.dir('trying to do tableChange...', newTbl);
				window.table = newTbl;
				await doTableChange();
			} catch (err) {
				console.dir('err', err);
			}
		}

		async function validateGroup(group) {
			console.log('method: validateGroup', group);
			try {
				const grp = await postData({ action: 'validateGroup', 'cards': group });
				console.dir('validateGroup', grp);
				return grp;
			} catch (err) {
				console.dir('err', err);
				return false;
			}
		}

		async function doTableChange() {
			console.log('method: doTableChange');
			try {
				let handCards = [];
				window.hand[0].cards.forEach( c => handCards.push({id: c, type: window.allCards[c].type, value: window.allCards[c].value}) );

				let fullTable = [];
				for(const s in window.table) {
					console.log('group_id...', s);
					let cardSet = [];
					window.table[s].cards.forEach( c => cardSet.push({id: c, type: window.allCards[c].type, value: window.allCards[c].value}) );
					if(cardSet.length) { // do not send empty sets by accident
						fullTable.push(cardSet);
					}
				}
				const turn = await postData({ action: 'doTableChange', 'playerId': window.playerId, 'table': fullTable, 'hand': handCards });
				console.dir('doTableChange', turn);
				// do all loading and rendering, table etc.... !!!!
				await getServerState();
				showTurnEnd();
			} catch (err) {
				console.dir('err', err);
			}
		}


		// non server interactive functions

		function createEmptySet() {
			console.log('method: createEmptySet');
			let set = {};
			set.id = "s" + Math.random().toString(12).substring(2, 8);
			set.cards = [];
			console.dir(set);
			window.sets.push(set);
			renderCardGroups(window.sets, guiNewSets);
		}

		function renderCardGroups(groups, gui) {
			console.log('method: renderCardGroups', groups);
			gui.innerHTML = '';
			for(const s in groups) {
				console.log('rendering group_id', groups[s].id);
				const nl = el('div', groups[s].id, `id: ${groups[s].id}`);

				if (groups[s].id != 0) { // not for hand
					const butt0 = el('button', "act0-" + groups[s].id, '++X');
					butt0.addEventListener('click', (e) => addActiveCardsToSet(groups[s].id, true), true);
					nl.appendChild(butt0);
				}

				groups[s].cards.forEach( c => {
					const card = renderCard(c);
					card.addEventListener('click', (e) => activateCard(c), true);
					nl.appendChild(card);
				});

				if (groups[s].id !== 0) { // not for hand
					const butt = el('button', "act-" + groups[s].id, 'X++');
					butt.addEventListener('click', (e) => addActiveCardsToSet(groups[s].id), true);
					nl.appendChild(butt);
				}
				gui.appendChild(nl);
			}
		}

		function addActiveCardsToSet(setId, toTheStart = false) {
			console.log('method: addActiveCardsToSet', setId, toTheStart, window.actives, window.sets);

			if (toTheStart) {
				window.actives.reverse();
			}

			window.actives.forEach( a => {
				console.dir('iterating window.actives', a);
				// do hand adds and removes
				const y = window.hand[0].cards.indexOf(a);
				if (y > -1) {
					window.hand[0].cards.splice(y, 1);
				} else if (setId === 0) {
					toTheStart ? window.hand[0].cards.unshift(a) : window.hand[0].cards.push(a);
					// add sort!!
				}

				// do table groups adds and removes
				window.table.forEach( (grp, idx) => {
					const x = grp.cards.indexOf(a);
					if (x > -1) {
						window.table[idx].cards.splice(x, 1);
					} else if (setId === window.table[idx].id) {
						toTheStart ? window.table[idx].cards.unshift(a) : window.table[idx].cards.push(a);
						// add sort!!
					}
				});

				// do new sets adds and removes
				window.sets.forEach( (grp, idx) => {
					console.log('iterating via group', grp, idx);
					const z = grp.cards.indexOf(a);
					if (z > -1) {
						window.sets[idx].cards.splice(z, 1);
					} else if (setId === window.sets[idx].id) {
						toTheStart ? window.sets[idx].cards.unshift(a) : window.sets[idx].cards.push(a);
						// add sort!!
					}
				});
			});

			window.actives = [];
			renderCardGroups(window.sets, guiNewSets);
			renderCardGroups(window.hand, guiHand);
			renderCardGroups(window.table, guiTable);
		}

		function renderCard(id) {
			const types = {spades: '&spades;', hearts: '&hearts;', diamonds: '&diams;', clubs: '&clubs;', wildcard: '&#10029;'};
			let card = el('div', id, `${window.allCards[id].value} ${types[window.allCards[id].type]}`);
			let attr = document.createAttribute("class");
			attr.value = window.allCards[id].type + " " + window.allCards[id].value;
			card.setAttributeNode(attr);
			return card;
		}

		function activateCard(id) {
			const x = window.actives.indexOf(id);
			if (x > -1) {
				window.actives.splice(x, 1);
			} else {
				window.actives.push(id)	
			}
			document.getElementById(id).classList.toggle("active");
			event.stopPropagation();
		}

		function el(element, id, htmlBody) {
			let el = document.createElement(element);
			el.innerHTML = htmlBody;
			el.id = id;
			return el;
		}

		function showTurnEnd() {
			document.getElementById("indicator").animate(
				[
					{ letterSpacing: '1px', color: '#000' },
					{ letterSpacing: '10px', color: '#0a0' },
					{ letterSpacing: '1px', color: '#000' }
				], 500);
		}
	</script>
</head>
<body>

<h3 id="indicator">Decomposed Joker GUI</h3>

<button onclick='initGame()'>Init Game</button>
<button onclick='registerPlayer("marek")'>registerPlayer</button>
<button onclick='getServerState()'>refresh / reset</button> 
<!--button onclick='getHand(true)'>getHand and renderHand</button>
<button onclick='getTable(true)'>getTable and renderTable</button--> ||  ||  || 
<button onclick='getCard(true)'>getCard and end turn</button>
<button onclick='validateAndDoTurn()'>validate all groups and end turn</button>
<hr>
Hand:
<div id='guiHand'></div>
NewSets: <button onclick='createEmptySet()'>create Empty Set</button>
<div id='guiNewSets'></div>
Table
<div id='guiTable'></div>
<hr>


</body>
</html>
