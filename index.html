<!doctype html>
<html lang="cs" id="html">
<head>
	<meta charset="utf-8">
	<title>Decomposed Joker GUI</title>
	<link rel="icon" type="image/png" href="favicon.ashx">
	<style>
		html {background: radial-gradient(circle, rgb(166,221,129) 13%, rgb(37,152,53) 84%); height:100%; color: White; font-family: serif;}
		body {margin: 0px;}
		div#guiHand div div, div#guiTable div div {width: 38px; height: 70px; display: inline-block; overflow: hidden; cursor: pointer; border: 1px solid Black; margin-left: 2px; border-radius: 4px; user-select: none; padding: 2px; font-size: 1.4em; vertical-align: middle;}
		/* clusmy attempt of dynamic scaling based on number of cards in the set */
		div#guiTable div.c5 div {margin-left: -4px;}
		div#guiTable div.c6 div {margin-left: -8px;}
		div#guiTable div.c7 div {margin-left: -12px;}
		div#guiTable div.c8 div {margin-left: -15px;}
		div#guiTable div.c9 div {margin-left: -15px; width: 32px;}
		div#guiTable div.c10 div {margin-left: -15px; width: 32px;}
		div#guiTable div.c11 div {margin-left: -18px; width: 32px;}
		div#guiTable div.c12 div {margin-left: -18px; width: 29px;}
		div#guiTable div.c13 div {margin-left: -18px; width: 29px;}
		div#guiTable div.c14 div {margin-left: -18px; width: 29px;}
		div#guiTable div.c14 div {margin-left: -18px; width: 29px;}
		div#guiTable div img {width: 44px; height: 76px; display: inline-block; vertical-align: top; padding: 2px; margin-right: 0; user-select: none;}
		div#guiPlayers div {width: 96%; display: inline-block; margin: 2px; padding: 4px; background-image: linear-gradient(to right, BurlyWood, transparent); border-radius: 5px;}
		div.active {border: 2px solid DarkGreen; filter: drop-shadow(-3px 3px 1px Black); background-color: LightCyan !important; color: Black;}
		div.spades {background-color: White; color: Black;} 
		div.clubs {background-color: MistyRose; color: Black;}
		div.hearts {background-color: Cornsilk; color: Red;}
		div.diamonds {background-color: Ivory; color: Red;}
		div.wildcard {background-color: White; color: DarkOrange; background-image: url(joker.svg); background-repeat:no-repeat; background-position: center center; }
		div > p {margin: 0; padding: 0;}
		div > p:nth-of-type(1) {text-align: left;}
		div > p:nth-of-type(2) {text-align: center;}
		div > p:nth-of-type(3) {text-align: right;}
		h1 {text-align: center; margin: 3px; padding: 1px; font-size: 1.8em;}
		div.menu img {width: 128px; margin: 0px auto; display: block;}
		h3 {text-align: center; color: Pink;}
		div#guiTable {column-count: 2;}
		div.menu button {width: 100%; padding: 4px;}
		div#actions {font-size: 1.6em; position: fixed; left: 68%; top: 80%;}
		div#actions button {background-color: Beige; filter: drop-shadow(2px 2px 12px Gold); border-radius: 8px; padding: 6px; margin-bottom: 3px;}
		button {display: inline-block; vertical-align: middle; background-color: Gold; font-size: 1.2em; border-radius: 6px; margin: 2px; font-family: serif;}
		div div.changed {border: 2px dotted Red !important;}
		span#dragTarget {cursor: move; color: Black; font-size: 1.7em;}
		h6 {font-style: italic; font-size: 1.1em; opacity: 0.5; font-weight: lighter; padding: 0; margin: -4px 0 0 -2px;}
		/* main layout */
		.wrapper {display: grid; grid-gap: 0; grid-template-columns: repeat(5, [col] 19.9% ); grid-template-rows: repeat(4, [row] auto ); width: 100vw; height: 100vh;}
		.box {background-color: rgba(0,0,0,0.4); border-radius: 4px; padding: 8px; margin: 5px;}
		.menu {grid-column: col; grid-row: row / span 2;}
		.players {grid-column: col; grid-row: row 3 / span 2;}
		.hand {grid-column: col 2 / span 4; grid-row: row;}
		.table {grid-column: col 2 / span 4; grid-row: row 2 / span 3;}

	</style>
	<script>
		"use strict";

		var allCards = {}; // all current game cards in the full deck
		var playerId = ''; // current player secret identifier
		var canModifyTable = false; // flag, if user already made one full set and can add cards to other sets
		var players = {}; // all players involved in current game
		var hand = []; // player's cards in hand
		var lastHandCards = {a: [], b: []}; // previous player's cards in hand history, last two changes
		var sets = []; // preparing, unfinished, unvalidated, new sets of cards (client side only)
		var table = []; // playing table with validated sets of cards (server side)
		var lastTableCards = {a: [], b: []}; // previous table's cards history, last two changes
		var actives = []; // stack of currently selected cards (to create new set or append to existing one)
		var gameStatus = 'inactive'; // current game status: inactive | playing | finished
		var myTurn = false; // flag if it is this player's turn or not
		var tick; // holder for refresing/ticking setInterval object
		var lastModifiedAt = 0; // unix timestamp of the last time server side game has been modified
		var guiHand;
		var guiTable;
		var guiPlayers;
		var guiActions;

		window.addEventListener('load', (event) => {
			console.log('method: document loaded...');

			window.guiHand = document.getElementById('guiHand');
			window.guiHand.innerHTML = '';
			window.guiTable = document.getElementById('guiTable');
			window.guiTable.innerHTML = '';
			window.guiPlayers = document.getElementById('guiPlayers');
			window.guiPlayers.innerHTML = '';

			window.guiActions = document.getElementById('actions');
			let dt = document.getElementById('dragTarget');
			dt.onmousedown = mouse1;
			dt.ondragstart = mouse2;
		});

		document.addEventListener('keydown', evalKey);

		async function postData(data = {}) {
			// Default options are marked with *
			const response = await fetch('api.php', {
				method: 'POST', // *GET, POST, PUT, DELETE, etc.
				mode: 'cors', // no-cors, *cors, same-origin
				cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
				credentials: 'same-origin', // include, *same-origin, omit
				headers: {
					'Content-Type': 'application/json'
				},
				redirect: 'follow', // manual, *follow, error
				referrerPolicy: 'no-referrer', // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url
				body: JSON.stringify(data, null, 2) // body data type must match "Content-Type" header
			});
			if (response.status == 304) {
				throw "Server responded with not-modified status";
			}
			const ret = await response.json(); // parses JSON response into native JavaScript objects
			if (response.status > 399) {
				throw "Server responded error with: " + ret.message;
			}
			console.dir('server call returned debug:', ret.dbg);
			return ret.data;
		}

		function evalKey(e) {
			console.dir('key pressed:', e.code);
			if (e.code == 'KeyS') { // try to perform 2 card swap
				if (window.gameStatus == 'playing' && window.actives.length == 2 && window.myTurn) {
					console.log('trying swap of cards:', window.actives);
					let hand = {id: 0, cards: [], controls: false}; // 0 = special setId and is always player's hand
					let table = [];

					window.hand[0].cards.forEach( (c) => {
						hand.cards.push( (c == actives[0]) ? actives[1] : (c == actives[1]) ? actives[0] : c );
					});

					for (let i in window.table) {
						let grp = {id: window.table[i].id, cards: [], controls: window.table[i].controls};
						window.table[i].cards.forEach( (c) => {
							grp.cards.push( (c == actives[0]) ? actives[1] : (c == actives[1]) ? actives[0] : c );
						});
						table.push(grp);
					}

					console.dir('swap changes', JSON.stringify(hand, null, 2), JSON.stringify(window.hand, null, 2), JSON.stringify(table, null, 2), JSON.stringify(window.table, null, 2));
					window.hand[0] = hand;
					window.table = table;
					window.actives = [];
					renderCardGroups(window.hand, window.guiHand, window.lastHandCards);
					renderCardGroups(window.table, window.guiTable, window.lastTableCards);
				}
			}
		}

		async function initGame() {
			console.log('method: initGame');
			try {
				const deck = await postData({ action: 'initGame' });
				deck.forEach(c => window.allCards[c.id] = c);
				//console.dir('initGame', window.allCards);
			} catch (err) {
				console.dir('err', err);
			}

			initHelper();
		}

		async function joinGame() {
			console.log('method: joinGame');  // add ID later !!!
			try {
				const deck = await postData({ action: 'getGameCards' });
				deck.forEach(c => window.allCards[c.id] = c);
				//console.dir('joinGame', window.allCards);
			} catch (err) {
				console.dir('err', err);
			}

			initHelper();
		}

		function initHelper() {
			console.log('method: initHeper');

			const hand = {id: 0, cards: [], controls: false}; // 0 = special setId and is always player's hand
			window.hand.push(hand);

			document.getElementById('guiGameInit').setAttribute('disabled', true);
			document.getElementById('guiGameJoin').setAttribute('disabled', true);
			document.getElementById('guiRegPlayer').removeAttribute('disabled');

			startAutoRefresh();
		}

		async function registerPlayer() {
			console.log('method: registerPlayer', window.localStorage.getItem('playerName'));
			const name = prompt("Please enter your name", window.localStorage.getItem('playerName') ? window.localStorage.getItem('playerName') : 'PlayerX');
			if (name != window.localStorage.getItem('playerName')) {
				window.localStorage.setItem('playerName', name);
			}
			try {
				const plr = await postData({ action: 'registerPlayer', 'name': name });
				if (plr.playerId) {
					window.playerId = plr.playerId;
					window.hand[0].cards = plr.hand;
					console.dir('registerPlayer', plr);
					document.getElementById('guiRegPlayer').removeAttribute('disabled');
					document.getElementById('indicator').innerText = 'Player: '+ name;
					document.getElementById('guiRegPlayer').setAttribute('disabled', true);
					document.getElementById('guiGameStart').removeAttribute('disabled');
					renderCardGroups(window.hand, window.guiHand, window.lastHandCards);
				}
			} catch (err) {
				console.dir('err', err);
				showFailure();
			}
		}

		async function startGame() {
			console.log('method: startGame', window.playerId);
			try {
				if (await postData({ action: 'setActivePlayer', 'playerId': window.playerId })) {
					console.dir('startGame', true);
					await getHand(true);
					window.gameStatus = 'playing';
					//window.myTurn = true;
					document.getElementById('guiGameStart').setAttribute('disabled', true);
					document.getElementById('guiTurnGetCard').removeAttribute('disabled');
					document.getElementById('guiTurnChangeTable').removeAttribute('disabled');
				} else {
					throw 'Setting player as active failed';
				}
			} catch (err) {
				console.dir('err', err);
				showFailure();
			}
		}

		async function getGameInfo(render = false) {
			console.log('method: getGameInfo');
			if (!window.myTurn && !document.hidden) {
				document.getElementById('guiTurnGetCard').setAttribute('disabled', true);
				document.getElementById('guiTurnChangeTable').setAttribute('disabled', true);
				try {
					const p = await postData({ action: 'getGameInfo', 'playerId': window.playerId, 'knownStateFrom': window.lastModifiedAt });
					// changed state?
					const change = (window.gameStatus != p.gameStatus || window.myTurn != p.amIActivePlayer) ? true : false;
					window.gameStatus = p.gameStatus;
					window.players = p.players;
					window.myTurn = p.amIActivePlayer;
					window.lastModifiedAt = p.lastModifiedAt;
					console.dir('players and gameStatus', window.players, window.gameStatus);
					showTurnEnd();
					if (render) {
						renderGameInfo(change);
					}
					if (window.gameStatus == 'finished') {
						startAutoRefresh(true);
						alert('Game Over');
					}
				} catch (err) {
					console.dir('err', err);
				}
			} else {
				document.getElementById('guiTurnGetCard').removeAttribute('disabled');
				document.getElementById('guiTurnChangeTable').removeAttribute('disabled');
			}
		}

		// let it run all the time
		function startAutoRefresh(forceReset = false) {
			console.log('method: autoRefresh');
			try {
				if (forceReset) {
					window.clearInterval(window.tick);
					return;
				}
				if (!window.tick) {
					window.tick = window.setInterval( async () => { await getGameInfo(true); }, 1000);
				} else {
					//window.clearInterval(window.tick);
				}
			} catch (err) {
				console.dir('err', err);
			}
		}

		async function getHand(render = false) {
			console.log('method: getHand');
			if (!window.playerId || !window.gameStatus == 'playing') {  // release a bit later
				return;
			}
			try {
				const hand = await postData({ action: 'getHand', 'playerId': window.playerId });
				// store previous hand cards
				window.lastHandCards.b = [...window.lastHandCards.a];
				window.lastHandCards.a = [...window.hand[0].cards];
				window.hand[0].cards = hand;
				window.hand[0].controls = false;
				console.dir('getHand', window.hand);
			} catch (err) {
				console.dir('err', err);
			}
			if (render) {
				renderCardGroups(window.hand, window.guiHand, window.lastHandCards);
			}
		}

		async function getCard(render = false) {
			console.log('method: getCard');
			if (!window.gameStatus == 'playing') {
				return;
			}
			try {
				if(await postData({ action: 'getCard', 'playerId': window.playerId })) {
					window.myTurn = false;
				}
			} catch (err) {
				console.dir('err', err);
				showFailure();
			}
			if (render) {
				await getHand(true);
			}
			//showTurnEnd();
		}

		async function getTable(render = false) {
			console.log('method: getTable');
			if (!window.gameStatus == 'playing') {
				return;
			}

			try {
				const tbl = await postData({ action: 'getTable', 'playerId': window.playerId });

				// store previous table cards
				window.lastTableCards.b = [...window.lastTableCards.a];
				window.lastTableCards.a = [];
				window.table.forEach( grp => {
					window.lastTableCards.a = grp.cards.concat(window.lastTableCards.a);
				});

				window.table = [];
				tbl.forEach( grp => {
					let set = {};
					set.id = "existing-" + Math.random().toString(12).substring(2, 8);
					set.controls = window.canModifyTable;
					set.cards = grp;
					window.table.push(set);
				});
				console.dir('getTable', window.table);
			} catch (err) {
				console.dir('err', err);
			}
			if (render) {
				renderCardGroups(window.table, window.guiTable, window.lastTableCards);
			}
		}

		async function getServerState() {
			console.log('method: getServerState');
			await getHand(true);
			await getTable(true);
			window.actives = [];
			window.sets = [];
		}

		async function validateGroup(group) {
			console.log('method: validateGroup', group);
			try {
				const grp = await postData({ action: 'validateGroup', 'cards': group });
				console.dir('validateGroup', grp);
				return grp;
			} catch (err) {
				console.dir('err', err);
				showFailure();
				return false;
			}
		}

		async function doTableChange() {
			console.log('method: doTableChange');
			if (!window.gameStatus == 'playing' || !window.myTurn) {
				return;
			}
			// try to be user friendly and validate active cards as new set
			// needs more robust logic in the future !!!!!!
			if (window.actives.length > 2) {
				const tmp = createEmptySet();
				addActiveCardsToSet(null, tmp.id);
			}

			try {
				let handCards = [];
				window.hand[0].cards.forEach( c => handCards.push({id: c, type: window.allCards[c].type, value: window.allCards[c].value}) );

				// merge prepared sets and xisting table to new table
				let newTbl = [];
				for(const s in window.table) {
					newTbl.push(window.table[s]);
				}
				for(const s in window.sets) {
					newTbl.push(window.sets[s]);
				}
				console.dir('trying to do tableChange as new table...', newTbl);
				window.table = newTbl;

				// and now try to do server side validation
				let fullTable = [];
				for(const s in window.table) {
					console.log('group_id on existing table...', s);
					let cardSet = [];
					window.table[s].cards.forEach( c => cardSet.push({id: c, type: window.allCards[c].type, value: window.allCards[c].value}) );
					if(cardSet.length) { // do not send empty sets by accident
						fullTable.push(cardSet);
					}
				}
				const turn = await postData({ action: 'doTableChange', 'playerId': window.playerId, 'table': fullTable, 'hand': handCards });
				console.dir('doTableChange ended as', turn);
				// do all loading and rendering, table etc.... !!!!
				await getServerState();
				//showTurnEnd();
				window.canModifyTable = true;
				if (turn == "won") {
					await getGameInfo(true);
					alert('Victory!!');
					startAutoRefresh(true);
				} else {
					window.myTurn = false;
				}
			} catch (err) {
				console.dir('err', err);
				showFailure();
			}
		}


		// non server interactive functions

		function createEmptySet(e = null) {
			if (e) {
				e.stopPropagation();
			}
			if (window.gameStatus != 'playing' || !window.myTurn) {
				return;
			}
			console.log('method: createEmptySet');
			let set = {};
			set.id = "new-" + Math.random().toString(12).substring(2, 8);
			set.controls = true;
			set.cards = [];
			window.table.push(set);
			if (window.actives.length) { // be pro-active and push cards there as well
				addActiveCardsToSet(null, set.id);
			}
			renderCardGroups(window.table, window.guiTable, window.lastTableCards);
			return set;
		}

		function renderCardGroups(groups, gui, previousIds) {
			console.log('method: renderCardGroups', JSON.stringify(groups, null, 2), 'previousIds', JSON.stringify(previousIds, null, 2));
			gui.innerHTML = '';
			for(const s in groups) {
				console.log('rendering group_id', groups[s].id);
				const nl = el('div', groups[s].id);
				nl.classList.add('c' + groups[s].cards.length);

				groups[s].cards.forEach( c => { // add cards
					const card = renderCard(c);
					if (window.gameStatus == 'playing') {
						card.addEventListener('click', (e) => activateCard(e, c), true);
					}
					// mark cards new from two previous known states
					if (previousIds.a.indexOf(c) == -1 || previousIds.b.indexOf(c) == -1) {
						card.classList.add('changed');
						console.dir('adding changed class to card id', c);
					}
					nl.append(card);
				});

				// solve case of empty set by rendering three cards
				if (!groups[s].cards.length && groups[s].id != 0) {
					console.log('rendering set as empty group');
					for (let a = 0; a < 3; a++) {
						let crd = el('img');
						crd.src = 'space.svg';
						nl.append(crd);
					}
				}

				if (groups[s].id != 0) { // not for hand
 					if (groups[s].cards.length) {
						const butt0 = el('img', "act0-" + groups[s].id);
						butt0.src = 'space.svg';
						if (groups[s].controls) {
							butt0.addEventListener('click', (e) => addActiveCardsToSet(e, groups[s].id, true), true);
						}
						nl.prepend(butt0);

						const butt = el('img', "act-" + groups[s].id);
						butt.src = 'space.svg';
						if (groups[s].controls) {
							butt.addEventListener('click', (e) => addActiveCardsToSet(e, groups[s].id), true);
						}
						nl.append(butt);
					} else {
						nl.addEventListener('click', (e) => addActiveCardsToSet(e, groups[s].id), true);
					}
				}

				gui.append(nl);
			}
		}

		function addActiveCardsToSet(e, setId, toTheStart = false) {
			console.log('method: addActiveCardsToSet', setId, toTheStart, window.actives, JSON.stringify(window.sets, null, 2), JSON.stringify(window.table, null, 2));
			if (e) {
				e.stopPropagation();
			}
			if (!window.gameStatus == 'playing' || !window.myTurn) {
				return false;
			}

			// validate if there is not card in the actives from the target set, which is invalid (for the time being)
			try {
				window.actives.forEach( a => {
					window.table.forEach( (grp, idx) => {
						const x = grp.cards.indexOf(a);
						if ((x > -1) && (setId == grp.id)) {
							console.dir('invalid!!!');
							throw "Invalid card : set combination";
						}
					});
					window.sets.forEach( (grp, idx) => {
						const x = grp.cards.indexOf(a);
						if ((x > -1) && (setId == grp.id)) {
							console.dir('invalid!!!');
							throw "Invalid card : set combination";
						}
					});
				});
			} catch (err) {
				console.dir('validation fail', err);
				showFailure();
				return false;	
			}

			console.dir('continue SET modification after passed validations');

			if (toTheStart && false) { // Jajca do not like it, skip it for now !!!!!
				window.actives.reverse();
			}

			window.actives.forEach( a => {
				console.dir('iterating window.actives', a);
				// do hand adds and removes
				const y = window.hand[0].cards.indexOf(a);
				if (y > -1) {
					window.hand[0].cards.splice(y, 1);
				} else if (setId === 0) {
					toTheStart ? window.hand[0].cards.unshift(a) : window.hand[0].cards.push(a);
					// add sort!!
				}

				// do table groups adds and removes
				window.table.forEach( (grp, idx) => {
					const x = grp.cards.indexOf(a);
					if (x > -1) {
						window.table[idx].cards.splice(x, 1);
					} else if (setId === window.table[idx].id) {
						toTheStart ? window.table[idx].cards.unshift(a) : window.table[idx].cards.push(a);
						// add sort!!
					}
				});

				// do new sets adds and removes
				window.sets.forEach( (grp, idx) => {
					console.log('iterating via group', grp, idx);
					const z = grp.cards.indexOf(a);
					if (z > -1) {
						window.sets[idx].cards.splice(z, 1);
					} else if (setId === window.sets[idx].id) {
						toTheStart ? window.sets[idx].cards.unshift(a) : window.sets[idx].cards.push(a);
						// add sort!!
					}
				});
			});

			window.actives = [];
			renderCardGroups(window.hand, window.guiHand, window.lastHandCards);
			renderCardGroups(window.table, window.guiTable, window.lastTableCards, window.canModifyTable);
		}

		function renderCard(id) {
			const m = {spades: '&spades;', hearts: '&hearts;', diamonds: '&diams;', clubs: '&clubs;', wildcard: '&nbsp;', 1: 'A', 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 10: 10, 11: 'J', 12: 'Q', 13: 'K', 0: '&zeta;'};
			let card = el('div', id, `<p>${m[window.allCards[id].value]}</p><p>${m[window.allCards[id].type]}</p><p>${m[window.allCards[id].value]}</p>`);
			card.classList.add(window.allCards[id].type, window.allCards[id].value);
			return card;
		}

		// and set action permissing, refactor later
		function renderGameInfo(refresh) {
			window.guiPlayers.innerHTML = '';
			for(const p in window.players) {
				let plr = el('div', null, `${window.players[p].name} (${window.players[p].cards} cards)`);
				plr.classList.add(window.players[p].status);
				guiPlayers.append(plr);
			}

			if (refresh) {
				if (window.gameStatus == 'playing') {
					document.getElementById('guiGameStart').setAttribute('disabled', true);
					document.getElementById('guiUndoRefresh').removeAttribute('disabled');
				}
				getServerState();
			}
		}

		function activateCard(e, id) {
			e.stopPropagation();
			if (!window.gameStatus == 'playing' || !window.myTurn) {
				return;
			}			
			const x = window.actives.indexOf(id);
			if (x > -1) {
				window.actives.splice(x, 1);
			} else {
				window.actives.push(id)	
			}
			document.getElementById(id).classList.toggle("active");
			event.stopPropagation();
		}

		function el(element, id = null, htmlBody = '') {
			let el = document.createElement(element);
			el.innerHTML = htmlBody;
			if (id) {
				el.id = id;
			}
			return el;
		}

		function showTurnEnd() {
			document.getElementById("html").animate(
				[
					{ background: 'radial-gradient(circle, rgb(166,221,129) 13%, rgb(37,152,53) 84%)' },
					{ background: 'Black' },
					{ background: 'radial-gradient(circle, rgb(166,221,129) 13%, rgb(37,152,53) 84%)' }
				], 700);
		}

		function showFailure() {
			document.getElementById("html").animate(
				[
					{ background: 'radial-gradient(circle, rgb(166,221,129) 13%, rgb(37,152,53) 84%)' },
					{ background: 'DarkRed' },
					{ background: 'radial-gradient(circle, rgb(166,221,129) 13%, rgb(37,152,53) 84%)' }
				], 1000);
		}

		// several methods related to freagging main actions around screen 
		var mouse1 = function(event) {
			let shiftX = event.clientX - guiActions.getBoundingClientRect().left;
			let shiftY = event.clientY - guiActions.getBoundingClientRect().top;
			document.body.append(guiActions);
			moveAt(event.pageX, event.pageY);

			// moves the ball at (pageX, pageY) coordinates
			// taking initial shifts into account
			function moveAt(pageX, pageY) {
				guiActions.style.left = pageX - shiftX + 'px';
				guiActions.style.top = pageY - shiftY + 'px';
			}

			function onMouseMove(event) {
				moveAt(event.pageX, event.pageY);
			}

			// move the ball on mousemove
			document.addEventListener('mousemove', onMouseMove);

			// drop the ball, remove unneeded handlers
			guiActions.onmouseup = function() {
				document.removeEventListener('mousemove', onMouseMove);
				guiActions.onmouseup = null;
			}
		}

		var mouse2 = function() {
			return false;
		}

	</script>
</head>
<body>

	<div id="actions">
		<button onclick='getCard(true)' id='guiTurnGetCard' disabled>&#10132; Get Card</button> &nbsp; <span id='dragTarget'>&#8689;</span><br>
		<button onclick='doTableChange()' id='guiTurnChangeTable' disabled>&#10148; Validate Changes</button>
	</div>

	<div class="wrapper">
		<div class="box menu">
			<img src="joker.svg">
			<h1>Decomposed Joker</h1>

			<button onclick='initGame()' id='guiGameInit'>&#9863; Init Game</button>
			<button onclick='joinGame()' id='guiGameJoin'>&#9865; Join Game</button>
			<button onclick='registerPlayer()' id='guiRegPlayer' disabled>&#8858; Register Player</button>
			<button onclick='startGame()' id='guiGameStart' disabled>&#128571; Start Game</button>
			<button onclick='getServerState()' id='guiUndoRefresh' disabled>&#8634; Refresh (Undo)</button>
			<hr>
			<h3 id="indicator"></h3>
		</div>

		<div class="box players">
			<h6>Players</h6>
			<div id='guiPlayers'></div>
		</div>

		<div class="box hand">
			<h6>Hand</h6>
			<div id='guiHand'></div>
		</div>

		<div class="box table" onclick='createEmptySet()'>
			<h6>Table</h6>
			<div id='guiTable'></div>
		</div>
	</div>

</body>
</html>

<!--
vyresit lepe zamky na fakt, ze nekdo muze chtit v jednom kole pripravit set a rovnou dokladat (poprve)
lepe vyresit konec hry, omezit statusy?
umoznit na konci jeste dolozit sve karty
nepreblikavat 2x provedenou zmenu (zkusit)
pridat podporu vice paralelnich her
4 z druhu jdou rozebrat i kdyz neni nahrada za jokera
vymena karty na prave tlacitko, ikonu nebo s klavesou, ani ruka by nemusela byt problem...
zkusit drzet ID sestav persistentne
vubec neposilat na validaci sestavy kratsi 3 karet
zrusit oramovani sestavy a upravit zobrazeni i prazdnych
zuzit levy sloupec
joker v ruce hlaska na GUI, mozna i jine
-->
