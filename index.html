<!doctype html>
<html lang="cs" id="html">
<head>
	<meta charset="utf-8">
	<title>Rozkládaný Žolík</title>
	<link rel="icon" type="image/png" href="favicon.ashx">
	<style>
		html {background: radial-gradient(circle, rgb(166,221,129) 13%, rgb(37,152,53) 84%); height:100%; color: White; font-family: serif;}
		body {margin: 0px;}
		div#guiHand div div, div#guiTable div div {width: 38px; height: 74px; display: inline-block; overflow: hidden; cursor: pointer; margin-left: 2px; border-radius: 4px; user-select: none; padding: 2px; font-size: 1.4em; vertical-align: middle;}
		div div.normal {border: 1px solid Black; transform: translateY(0);}
		div#guiTable div div.empty {border: 1px dashed #bbb; transform: translateY(0); padding: 0; background-image: url(space.svg); background-repeat: no-repeat; background-size: cover;}
		div div.active {filter: drop-shadow(-3px 3px 1px Black); background-color: LightCyan !important; transform: translateY(-7px) !important;}
		div div.changed {transform: translateY(7px) !important; filter: drop-shadow(-3px 3px 1px Black);}

		/* clusmy attempt of dynamic scaling based on number of cards in the set */
		div#guiTable div.c6 div {margin-left: -4px;}
		div#guiTable div.c7 div {margin-left: -7px;}
		div#guiTable div.c8 div {margin-left: -10px;}
		div#guiTable div.c9 div {margin-left: -10px; width: 32px;}
		div#guiTable div.c10 div {margin-left: -13px; width: 32px;}
		div#guiTable div.c11 div {margin-left: -16px; width: 32px;}
		div#guiTable div.c12 div {margin-left: -16px; width: 32px;}
		div#guiTable div.c13 div {margin-left: -16px; width: 32px;}
		div#guiTable div.c14 div {margin-left: -16px; width: 32px;}
		div#guiTable div.c15 div {margin-left: -16px; width: 32px;}
		div#guiTable div.c16 div {margin-left: -16px; width: 32px;}
		div#guiTable div.c17 div {margin-left: -16px; width: 32px;}

		div#guiPlayers div {width: 96%; display: inline-block; margin: 2px; padding: 4px; background-image: linear-gradient(to right, BurlyWood, transparent); border-radius: 5px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; opacity: .8;}
		div#guiPlayers > div.active {transform: translateY(0) !important; color: Black; opacity: 1;}
		div.spades {background-color: White; color: Black;} 
		div.clubs {background-color: MistyRose; color: Black;}
		div.hearts {background-color: Cornsilk; color: Red;}
		div.diamonds {background-color: Ivory; color: Red;}
		div.wildcard {background-color: White; color: DarkOrange; background-image: url(joker.svg); background-repeat:no-repeat; background-position: center center; }
		div > p {margin: 0; padding: 0;}
		div > p:nth-of-type(1) {text-align: left;}
		div > p:nth-of-type(2) {text-align: center;}
		div > p:nth-of-type(3) {text-align: right;}
		h1 {text-align: center; margin: 3px; padding: 1px; font-size: 1.8em;}
		div.menu img {width: 128px; margin: 0px auto; display: block;}
		h3 {font-size: 1.1em; text-align: left; color: Pink; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; margin: 5px auto;}
		/*div#guiTable {column-count: 2;}*/
		div#guiTable > div {margin-bottom: 8px; width: 49.5%; float: right;}
		div.menu button {width: 100%; padding: 4px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;}
		div#help {position: fixed; left: 5%; top: 5%; width: 80%; height: 80%; background-color: Beige; padding: 2em; color: Maroon; border-radius: 8px; border: 8px double DarkMaroon; display: none; overflow: scroll;}
		div#help ul {font-size: 1em; line-height: 150%; font-weight: normal;}
		div#help.visible {display: block;}
		div#help button {float: right;}
		div#turns {font-size: 0.8em; position: fixed; left: 1%; top: 1%; color: White;}
		div#actions {font-size: 1.6em; position: fixed; left: 68%; top: 80%;}
		div#actions button {background-color: Beige; filter: drop-shadow(2px 2px 12px Gold); border-radius: 8px; padding: 6px; margin-bottom: 3px; cursor: pointer;}
		button {display: inline-block; vertical-align: middle; background-color: Gold; font-size: 1.2em; border-radius: 6px; margin: 2px; font-family: serif;}
		span#dragTarget {cursor: move; color: Black; font-size: 1.7em;}
		h6 {font-style: italic; font-size: 1.1em; opacity: 0.5; font-weight: lighter; padding: 0; margin: -4px 0 0 -2px;}
		/* main layout */
		.wrapper {display: grid; grid-gap: 0; grid-template-columns: repeat(5, [col] 19.9% ); grid-template-rows: repeat(4, [row] auto ); width: 100vw; height: 100vh;}
		.box {background-color: rgba(0,0,0,0.4); border-radius: 4px; padding: 8px; margin: 5px;}
		.menu {grid-column: col; grid-row: row / span 2;}
		.players {grid-column: col; grid-row: row 3 / span 2;}
		.hand {grid-column: col 2 / span 4; grid-row: row;}
		.table {grid-column: col 2 / span 4; grid-row: row 2 / span 3;}

	</style>
	<script>
		"use strict";

		var allCards = {}; // all current game cards in the full deck
		var playerId = ''; // current player secret identifier
		var gameId = ''; // current game ID
		var canModifyTable = false; // flag, if user already made one full set and can add cards to other sets
		var players = {}; // all players involved in current game
		var hand = []; // player's cards in hand
		var lastHandCards = {a: [], b: [], c: []}; // previous player's cards in hand history, last change + c = reset
		var sets = []; // preparing, unfinished, unvalidated, new sets of cards (client side only)
		var table = []; // playing table with validated sets of cards (server side)
		var lastTableCards = {a: [], b: []}; // previous table's cards history, last two changes
		var actives = []; // stack of currently selected cards (to create new set or append to existing one)
		var gameStatus = 'inactive'; // current game status: inactive | playing | finished
		var myTurn = false; // flag if it is this player's turn or not
		var tick; // holder for refresing/ticking setInterval object
		var lastModifiedAt = 0; // unix timestamp of the last time server side game has been modified
		var guiHand;
		var guiTable;
		var guiPlayers;
		var guiActions;
		var audioObj = new Audio('cardflip.mp3');

		window.addEventListener('load', (event) => {
			console.log('method: document loaded...');

			window.guiHand = document.getElementById('guiHand');
			window.guiHand.innerHTML = '';
			window.guiTable = document.getElementById('guiTable');
			window.guiTable.innerHTML = '';
			window.guiPlayers = document.getElementById('guiPlayers');
			window.guiPlayers.innerHTML = '';

			window.guiActions = document.getElementById('actions');
			let dt = document.getElementById('dragTarget');
			dt.onmousedown = mouse1;
			dt.ondragstart = mouse2;
		});

		document.addEventListener('keydown', evalKey);

		async function postData(data = {}) {
			// Default options are marked with *
			const response = await fetch('api.php?' + data.action, {
				method: 'POST', // *GET, POST, PUT, DELETE, etc.
				mode: 'cors', // no-cors, *cors, same-origin
				cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
				credentials: 'same-origin', // include, *same-origin, omit
				headers: {
					'Content-Type': 'application/json'
				},
				redirect: 'follow', // manual, *follow, error
				referrerPolicy: 'no-referrer', // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url
				body: JSON.stringify(data, null, 2) // body data type must match "Content-Type" header
			});
			if (response.status == 304) {
				throw "Server responded with not-modified status";
			}
			const ret = await response.json(); // parses JSON response into native JavaScript objects
			if (response.status > 399) {
				throw "Server responded error with: " + ret.message;
			}
			console.dir('server call returned debug:', ret.dbg);
			return ret.data;
		}

		function evalKey(e) {
			console.dir('key pressed:', e.code);
			if (e.code == 'KeyS') { // try to perform 2 card swap
				if (window.gameStatus == 'playing' && window.actives.length == 2 && window.myTurn) {
					console.log('trying swap of cards:', window.actives);
					let hand = {id: 0, cards: [], controls: false}; // 0 = special setId and is always player's hand
					let table = [];

					window.hand[0].cards.forEach( (c) => {
						hand.cards.push( (c == actives[0]) ? actives[1] : (c == actives[1]) ? actives[0] : c );
					});

					for (let i in window.table) {
						let grp = {id: window.table[i].id, cards: [], controls: window.table[i].controls};
						window.table[i].cards.forEach( (c) => {
							grp.cards.push( (c == actives[0]) ? actives[1] : (c == actives[1]) ? actives[0] : c );
						});
						table.push(grp);
					}

					console.dir('swap changes', JSON.stringify(hand, null, 2), JSON.stringify(window.hand, null, 2), JSON.stringify(table, null, 2), JSON.stringify(window.table, null, 2));
					window.hand[0] = hand;
					window.table = table;
					window.actives = [];
					renderCardGroups(window.hand, window.guiHand, window.lastHandCards);
					renderCardGroups(window.table, window.guiTable, window.lastTableCards);
				}
			}
			if (e.code == 'KeyA') {
				console.log('trying activate first set + alter existing ones');
				firstDynamicUnlock();
			}
			if (e.code == 'Escape') {
				if (document.getElementById('help').classList.contains('visible')) {
					document.getElementById('help').classList.toggle('visible');
				}
			}
		}

		async function initGame() {
			console.log('method: initGame');
			try {
				window.gameId = await postData({ action: 'initGame' , 'gameId': window.gameId });
				const deck = await postData({ action: 'getGameCards', 'gameId': window.gameId });
				deck.forEach(c => window.allCards[c.id] = c);
				initHelper();
			} catch (err) {
				console.dir('err', err);
			}
		}

		async function joinGame() {
			console.log('method: joinGame');
			const str = window.prompt("Zadej kód hry, ke které se chcete připojit:", window.gameId ? window.gameId : '');
			if (!str) {
				return;
			}

			try {
				const deck = await postData({ action: 'getGameCards', 'gameId': str });
				deck.forEach(c => window.allCards[c.id] = c);
				window.gameId = str;
				initHelper();
			} catch (err) {
				console.dir('err', err);
				showFailure();
			}
		}

		function initHelper() {
			console.log('method: initHeper');

			window.hand[0] = {id: 0, cards: [], controls: false}; // 0 = special setId and is always player's hand

			document.getElementById('guiGameInit').setAttribute('disabled', true);
			document.getElementById('guiGameJoin').setAttribute('disabled', true);
			document.getElementById('guiRegPlayer').removeAttribute('disabled');
			document.getElementById('gameIndicator').innerText = 'Kód hry: '+ window.gameId;
			renderCardGroups(window.table, window.guiTable, window.lastTableCards);
			startAutoRefresh();
		}

		function finishHelper() {
			console.log('method: finishHeper');

			window.allCards = {};
			window.playerId = '';
			window.canModifyTable = false;
			window.players = {};
			window.hand = [];
			window.lastHandCards = {a: [], b: [], c: []};
			window.table = [];
			window.lastTableCards = {a: [], b: []};
			window.actives = [];
			window.gameStatus = 'inactive';
			window.myTurn = false;
			window.lastModifiedAt = 0;
			var guiHand;
			var guiTable;
			var guiPlayers;
			var guiActions;

			document.getElementById('guiGameInit').removeAttribute('disabled');
			document.getElementById('guiGameJoin').removeAttribute('disabled');
			document.getElementById('guiRegPlayer').setAttribute('disabled', true);
			document.getElementById('guiUndoRefresh').setAttribute('disabled', true);
		}

		async function registerPlayer() {
			console.log('method: registerPlayer', window.localStorage.getItem('playerName'));
			let name = window.prompt("Zadej jméno hráče:", window.localStorage.getItem('playerName') ? window.localStorage.getItem('playerName') : 'Hráč X');
			if (!name) {
				return;
			}
			if (name != window.localStorage.getItem('playerName')) {
				window.localStorage.setItem('playerName', name);
			}
			try {
				const plr = await postData({ action: 'registerPlayer', 'gameId': window.gameId, 'name': name });
				if (plr.playerId) {
					window.playerId = plr.playerId;
					window.hand[0].cards = plr.hand.slice();
					window.lastHandCards.c = plr.hand.slice();
					console.dir('registerPlayer', plr);
					document.getElementById('guiRegPlayer').removeAttribute('disabled');
					document.getElementById('indicator').innerText = 'Hráč: '+ name;
					document.getElementById('guiRegPlayer').setAttribute('disabled', true);
					document.getElementById('guiGameStart').removeAttribute('disabled');
					renderCardGroups(window.hand, window.guiHand, window.lastHandCards);
					audioObj.play();
				}
			} catch (err) {
				console.dir('err', err);
				showFailure();
			}
		}

		async function startGame() {
			console.log('method: startGame', window.playerId);
			try {
				if (await postData({ action: 'setActivePlayer', 'gameId': window.gameId, 'playerId': window.playerId })) {
					console.dir('startGame', true);
					window.gameStatus = 'playing';
					document.getElementById('guiGameStart').setAttribute('disabled', true);
					document.getElementById('guiTurnGetCard').removeAttribute('disabled');
					document.getElementById('guiTurnChangeTable').removeAttribute('disabled');
				} else {
					throw 'Setting player as active failed';
				}
			} catch (err) {
				console.dir('err', err);
				showFailure();
			}
		}

		async function getGameInfo(render = false) {
			console.log('method: getGameInfo');
			if (!window.myTurn && !document.hidden) {
				document.getElementById('guiTurnGetCard').setAttribute('disabled', true);
				document.getElementById('guiTurnChangeTable').setAttribute('disabled', true);
				try {
					const p = await postData({ action: 'getGameInfo', 'gameId': window.gameId, 'playerId': window.playerId, 'knownStateFrom': window.lastModifiedAt });
					console.dir('returned server info', JSON.stringify(p, null, 2));
					// changed state?
					const change = (window.gameStatus !== p.gameStatus || window.myTurn !== p.amIActivePlayer || p.lastModifiedAt !== window.lastModifiedAt) ? true : false;
					window.gameStatus = p.gameStatus;
					window.players = p.players;
					window.myTurn = p.amIActivePlayer;
					window.lastModifiedAt = p.lastModifiedAt;
					document.getElementById('turns').innerText = p.turns;
					console.dir('players and gameStatus', window.players, window.gameStatus);
					showSuccess();
					if (render) {
						renderGameInfo(change);
					}
					if (window.gameStatus === 'finished') {
						await getGameInfo(true);
						startAutoRefresh(true);
						showFinish();
						alert('Konec hry!');
						finishHelper();
					}
				} catch (err) {
					console.dir('err', err);
				}
			} else {
				document.getElementById('guiTurnGetCard').removeAttribute('disabled');
				document.getElementById('guiTurnChangeTable').removeAttribute('disabled');
			}
		}

		// let it run all the time
		function startAutoRefresh(forceReset = false) {
			console.log('method: autoRefresh');
			try {
				if (forceReset) {
					window.clearInterval(window.tick);
					return;
				}
				if (!window.tick) {
					window.tick = window.setInterval( async () => { await getGameInfo(true); }, 1000);
				} else {
					//window.clearInterval(window.tick);
				}
			} catch (err) {
				console.dir('err', err);
			}
		}

		async function getHand() {
			console.log('method: getHand');
			if (!window.playerId || !window.gameStatus === 'playing') {  // release a bit later
				return;
			}
			try {
				const hand = await postData({ action: 'getHand', 'gameId': window.gameId, 'playerId': window.playerId });
				//console.dir('hand change before', JSON.stringify(window.hand, null, 2), JSON.stringify(window.lastHandCards, null, 2));
				window.lastHandCards.c = hand.slice(); // reset state
				window.lastHandCards.b = window.lastHandCards.a.slice();
				window.lastHandCards.a = window.hand[0].cards.slice();
				window.hand[0].cards = hand.slice();
				window.hand[0].controls = false;
				//console.dir('hand change after', JSON.stringify(window.hand, null, 2), JSON.stringify(window.lastHandCards, null, 2));
				console.dir('getHand success', window.hand);
			} catch (err) {
				console.dir('err', err);
			}
		}

		async function getCard() {
			console.log('method: getCard');
			if (!window.gameStatus === 'playing') {
				return;
			}
			// do re-check if it is really intended step to do
			if (window.lastHandCards.c.toString() !== window.hand[0].cards.toString()) {
			 	if(window.confirm('Opravdu si vzít kartu?')) {
			 		// player really wants to abandon current changes
					console.log('player wants to really get new card, doing hand reset');
					window.hand[0].cards = window.lastHandCards.c.slice();
					audioObj.play();
			 	} else {
			 		console.log('player does not want to take new card');
			 		return; // no, it is a mistake
			 	}
			}

			try {
				if(await postData({ action: 'getCard', 'gameId': window.gameId, 'playerId': window.playerId })) {
					window.myTurn = false;
				}
			} catch (err) {
				console.dir('err', err);
				showFailure();
			}
		}

		async function getTable() {
			console.log('method: getTable');
			if (!window.gameStatus == 'playing') {
				return;
			}

			try {
				const tbl = await postData({ action: 'getTable', 'gameId': window.gameId, 'playerId': window.playerId });

				const comp = ['id', 'cards']; // which properties are significant
				console.dir('comparing new and previous table', JSON.stringify(tbl, comp), JSON.stringify(window.table, comp));
				// store previous table cards and update objects, if changed only
				if (JSON.stringify(tbl, comp) === JSON.stringify(window.table, comp)) {
					console.log('tables seems to be the same, exiting without changes');
					return;
				}
				window.lastTableCards.b = window.lastTableCards.a.slice();
				window.lastTableCards.a = [];
				window.table.forEach( grp => {
					grp.cards.forEach( c => {
						window.lastTableCards.a.push(grp.id + "_" + c);
					});
				});

				window.table = [];
				tbl.forEach( grp => {
					window.table.push({id: grp.id, controls: window.canModifyTable, cards: grp.cards.slice()});
				});
				console.dir('getTable results', window.table, window.lastTableCards);
			} catch (err) {
				console.dir('err', err);
			}
		}

		async function getServerState(preserveHistory) {
			console.log('method: getServerState', preserveHistory);
			
			// store last changes history
			let ah, at;
			if (preserveHistory) {
				ah = window.lastHandCards.a;
				at = window.lastTableCards.a;
			}

			await getHand();
			await getTable();

			// and now return it
			if (preserveHistory) {
				window.lastHandCards.a = ah.slice();
				window.lastHandCards.b = ah.slice();
				window.lastTableCards.a = at.slice();
			}

			renderCardGroups(window.hand, window.guiHand, window.lastHandCards);
			renderCardGroups(window.table, window.guiTable, window.lastTableCards);
			window.actives = [];
			audioObj.play();
		}

		async function validateGroup(group) {
			console.log('method: validateGroup', group);
			try {
				let cardSet = {id: group.id, cards:[]};
				group.forEach( c => cardSet.cards.push({id: c, type: window.allCards[c].type, value: window.allCards[c].value}) );
				const grp = await postData({ action: 'validateGroup', 'cards': cardSet });
				console.dir('validateGroup', grp);
				return grp;
			} catch (err) {
				console.dir('err', err);
				showFailure();
				return false;
			}
		}

		async function doTableChange() {
			console.log('method: doTableChange');
			if (!window.gameStatus === 'playing' || !window.myTurn) {
				return;
			}
			// try to be user friendly and validate active cards as new set
			// needs more robust logic in the future !!!!!!
			if (window.actives.length > 2) {
				const tmp = createEmptySet();
				addActiveCardsToSet(null, tmp.id);
			}

			try {
				let handCards = [];
				window.hand[0].cards.forEach( c => handCards.push({id: c, type: window.allCards[c].type, value: window.allCards[c].value}) );

				// and now try to do server side validation
				let fullTable = [];
				for(const s in window.table) {
					console.log('group_id on existing table...', s);
					let cardSet = {id: window.table[s].id, cards:[]};
					window.table[s].cards.forEach( c => cardSet.cards.push({id: c, type: window.allCards[c].type, value: window.allCards[c].value}) );
					if(cardSet.cards.length) { // do not send empty sets by accident
						fullTable.push(cardSet);
					}
				}
				const turn = await postData({ action: 'doTableChange', 'gameId': window.gameId, 'playerId': window.playerId, 'table': fullTable, 'hand': handCards });
				console.dir('doTableChange ended as', turn);
				window.canModifyTable = true;
				if (turn === "won") {
					await getGameInfo(true);
					startAutoRefresh(true);
					showFinish();
					alert('Hurá! Vítězství!');
					finishHelper();
				} else {
					// try to push history forward
					window.lastTableCards.b = window.lastTableCards.a.slice();
					window.lastTableCards.a = [];
					window.table.forEach( grp => {
						grp.cards.forEach( c => {
							window.lastTableCards.a.push(grp.id + "_" + c);
						});
					});

					window.myTurn = false;
					audioObj.play();
				}
			} catch (err) {
				console.dir('err', err);
				showFailure();
			}
		}


		// non server interactive functions

		// for cases when user wants to introduce new card group + modify existing sets
		async function firstDynamicUnlock() {
			console.log('method: firstDynamicUnlock');
			// user should have at least one new valid set from hand ready
			if (window.gameStatus === 'playing' && window.hand[0].cards.length < window.lastHandCards.c.length) {
				for (let i in window.table) {
					// following condition is no longer valid, re-made it !!
					//if (window.table[i].id.indexOf('new') === 0 && window.table[i].cards.length) {
						let valid = await validateGroup(window.table[i].cards);
						if (valid) {
							window.canModifyTable = true;
							break;
						}
					//}
				}
				if (window.canModifyTable) {
					for (let i in window.table) {
						window.table[i].controls = true;
					}
					renderCardGroups(window.table, window.guiTable, window.lastTableCards);
				}
			}
			if (!window.canModifyTable) {
				showFailure();
			} else {
				showSuccess();
			}
		}

		function createEmptySet(e = null) {
			if (e) {
				e.stopPropagation();
			}
			if (window.gameStatus != 'playing' || !window.myTurn) {
				return;
			}
			console.log('method: createEmptySet');
			let set = {};
			set.id = Math.random().toString(36).substring(2, 8);
			set.new = true;
			set.controls = true;
			set.cards = [];
			window.table.push(set);
			if (window.actives.length) { // be pro-active and push cards there as well
				addActiveCardsToSet(null, set.id);
			}
			renderCardGroups(window.table, window.guiTable, window.lastTableCards);
			return set;
		}

		function renderCardGroups(groups, gui, previousIds) {
			console.log('method: renderCardGroups', JSON.stringify(groups, null, 2), 'previousIds', JSON.stringify(previousIds, null, 2));
			gui.innerHTML = '';
			for(const s in groups) {
				console.log('rendering group_id', groups[s].id);
				const nl = el('div', groups[s].id);
				nl.classList.add('c' + groups[s].cards.length);

				groups[s].cards.forEach( c => { // add cards
					const card = renderCard(c);
					if (window.gameStatus === 'playing' && (groups[s].controls || groups[s].id === 0)) {
						card.addEventListener('click', (e) => activateCard(e, c), true);
					} else {
						card.addEventListener('click', (e) => dummyClick(e), true);
					}
					// mark cards new from two previous known states, but not new sets
					if (groups[s].id != 0) { // not hand, table has indexes with group prefixes
						if (!groups[s].new && (!previousIds.a.includes(groups[s].id + "_" + c) /*|| !previousIds.b.includes(groups[s].id + "_" + c)*/)) {
							card.classList.add('changed');
							console.dir('adding changed class to table card id', c);
						} else {
							card.classList.add('normal');
						}
					} else { // hand
						if (!groups[s].new && (!previousIds.a.includes(c) || !previousIds.b.includes(c))) {
							card.classList.add('changed');
							console.dir('adding changed class to hand card id', c);
						} else {
							card.classList.add('normal');
						}
					}
					nl.append(card);
				});

				// solve case of empty set by rendering three cards
				if (!groups[s].cards.length && groups[s].id !== 0) {
					console.log('rendering set as empty group');
					for (let a = 0; a < 3; a++) {
						const wrapper = el('div');
						wrapper.classList.add('empty');
						nl.append(wrapper);
					}
				}

				if (groups[s].id != 0) { // not for hand
 					if (groups[s].cards.length) {
						const wrapper0 = el('div');
						wrapper0.classList.add('empty');
						if (groups[s].controls) {
							wrapper0.addEventListener('click', (e) => addActiveCardsToSet(e, groups[s].id, true), true);
						} else {
							wrapper0.addEventListener('click', (e) => dummyClick(e), true);
						}
						nl.prepend(wrapper0);

						const wrapper = el('div');
						wrapper.classList.add('empty');
						if (groups[s].controls) {
							wrapper.addEventListener('click', (e) => addActiveCardsToSet(e, groups[s].id), true);
						} else {
							wrapper.addEventListener('click', (e) => dummyClick(e), true);
						}
						nl.append(wrapper);
					} else {
						nl.addEventListener('click', (e) => addActiveCardsToSet(e, groups[s].id), true);
					}
				}

				gui.append(nl);
			}
		}

		function addActiveCardsToSet(e, setId, toTheStart = false) {
			console.log('method: addActiveCardsToSet', setId, toTheStart, window.actives, JSON.stringify(window.table, null, 2));
			if (e) {
				e.stopPropagation();
			}
			if (!window.gameStatus === 'playing' || !window.myTurn) {
				return false;
			}

			// validate if there is not card in the actives from the target set, which is invalid (for the time being)
			try {
				window.actives.forEach( a => {
					window.table.forEach( (grp, idx) => {
						if (grp.cards.includes(a) && (setId == grp.id)) {
							console.dir('invalid!!!');
							throw "Invalid card : set combination";
						}
					});
				});
			} catch (err) {
				console.dir('validation fail', err);
				showFailure();
				return false;	
			}

			console.dir('continue SET modification after passed validations');

			if (toTheStart && false) { // Jajca do not like it, skip it for now !!!!!
				window.actives.reverse();
			}

			window.actives.forEach( a => {
				console.dir('iterating window.actives', a);
				// do hand adds and removes
				const y = window.hand[0].cards.indexOf(a);
				if (y > -1) {
					window.hand[0].cards.splice(y, 1);
				} else if (setId === 0) {
					toTheStart ? window.hand[0].cards.unshift(a) : window.hand[0].cards.push(a);
					// add sort!!
				}

				// do table groups adds and removes
				window.table.forEach( (grp, idx) => {
					const x = grp.cards.indexOf(a);
					if (x > -1) {
						window.table[idx].cards.splice(x, 1);
					} else if (setId === window.table[idx].id) {
						toTheStart ? window.table[idx].cards.unshift(a) : window.table[idx].cards.push(a);
						// add sort!!
					}
				});

			});

			window.actives = [];
			renderCardGroups(window.hand, window.guiHand, window.lastHandCards);
			renderCardGroups(window.table, window.guiTable, window.lastTableCards, window.canModifyTable);
		}

		function renderCard(id) {
			const m = {spades: '&spades;', hearts: '&hearts;', diamonds: '&diams;', clubs: '&clubs;', wildcard: '&nbsp;', 1: 'A', 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 10: 10, 11: 'J', 12: 'Q', 13: 'K', 0: '&zeta;'};
			let card = el('div', id, `<p>${m[window.allCards[id].value]}</p><p>${m[window.allCards[id].type]}</p><p>${m[window.allCards[id].value]}</p>`);
			card.classList.add(window.allCards[id].type, window.allCards[id].value);
			return card;
		}

		// and set action permissing, refactor later
		function renderGameInfo(refresh) {
			window.guiPlayers.innerHTML = '';
			for(const p in window.players) {
				let plr = el('div', null, `${window.players[p].name} (${window.players[p].cards} cards)`);
				plr.classList.add(window.players[p].status);
				guiPlayers.append(plr);
			}

			if (refresh) {
				if (window.gameStatus === 'playing') {
					document.getElementById('guiGameStart').setAttribute('disabled', true);
					document.getElementById('guiUndoRefresh').removeAttribute('disabled');
				}
				getServerState(false);
			}
		}

		function activateCard(e, id) {
			console.dir('method: activateCard', id);
			e.stopPropagation();
			if (window.gameStatus !== 'playing' || !window.myTurn) {
				return;
			}			
			const x = window.actives.indexOf(id);
			if (x > -1) {
				window.actives.splice(x, 1);
			} else {
				window.actives.push(id)	
			}
			document.getElementById(id).classList.toggle("active");
			event.stopPropagation();
		}

		function el(element, id = null, htmlBody = '') {
			let el = document.createElement(element);
			el.innerHTML = htmlBody;
			if (id) {
				el.id = id;
			}
			return el;
		}

		function showSuccess() {
			document.getElementById("html").animate(
				[
					{ background: 'radial-gradient(circle, rgb(166,221,129) 13%, rgb(37,152,53) 84%)' },
					{ background: 'Blue' },
					{ background: 'radial-gradient(circle, rgb(166,221,129) 13%, rgb(37,152,53) 84%)' }
				], 800);
		}

		function showFailure() {
			document.getElementById("html").animate(
				[
					{ background: 'radial-gradient(circle, rgb(166,221,129) 13%, rgb(37,152,53) 84%)' },
					{ background: 'DarkRed' },
					{ background: 'radial-gradient(circle, rgb(166,221,129) 13%, rgb(37,152,53) 84%)' }
				], 1000);
		}

		function showFinish() {
			document.getElementById("html").animate(
				[
					{ background: 'radial-gradient(circle, rgb(166,221,129) 13%, rgb(37,152,53) 84%)' },
					{ background: 'White' },
					{ background: 'radial-gradient(circle, rgb(166,221,129) 13%, rgb(37,152,53) 84%)' }
				], {duration: 1000, iterations: 3});
		}

		function dummyClick(e) {
			console.dir('method: dummyClick');
			e.stopPropagation();
		}

		// several methods related to freagging main actions around screen 
		var mouse1 = function(event) {
			let shiftX = event.clientX - guiActions.getBoundingClientRect().left;
			let shiftY = event.clientY - guiActions.getBoundingClientRect().top;
			document.body.append(guiActions);
			moveAt(event.pageX, event.pageY);

			// moves the ball at (pageX, pageY) coordinates
			// taking initial shifts into account
			function moveAt(pageX, pageY) {
				guiActions.style.left = pageX - shiftX + 'px';
				guiActions.style.top = pageY - shiftY + 'px';
			}

			function onMouseMove(event) {
				moveAt(event.pageX, event.pageY);
			}

			// move the ball on mousemove
			document.addEventListener('mousemove', onMouseMove);

			// drop the ball, remove unneeded handlers
			guiActions.onmouseup = function() {
				document.removeEventListener('mousemove', onMouseMove);
				guiActions.onmouseup = null;
			}
		}

		var mouse2 = function() {
			return false;
		}

	</script>
</head>
<body>

	<div class="wrapper">
		<div class="box menu">
			<img src="joker.svg">
			<h1>Rozkládaný žolík</h1>

			<button onclick='initGame()' id='guiGameInit'>&#9863; Založit hru</button>
			<button onclick='joinGame()' id='guiGameJoin'>&#9865; Připojit se</button>
			<button onclick='registerPlayer()' id='guiRegPlayer' disabled>&#8858; Registrovat hráče</button>
			<button onclick='startGame()' id='guiGameStart' disabled>&#128571; Zahájit hru</button>
			<button onclick='getServerState(true)' id='guiUndoRefresh' disabled>&#8634; Obnovit (Zpět)</button>
			<button onclick='document.getElementById("help").classList.toggle("visible")'>? Nápověda</button>
			
			<h3 id="gameIndicator"></h3>
			<h3 id="indicator"></h3>
		</div>

		<div class="box players">
			<h6>Hráči</h6>
			<div id='guiPlayers'></div>
		</div>

		<div class="box hand">
			<h6>Ruka</h6>
			<div id='guiHand'></div>
		</div>

		<div class="box table" onclick='createEmptySet()'>
			<h6>Stůl</h6>
			<div id='guiTable'></div>
		</div>
	</div>

	<div id="turns"></div>

	<div id="actions">
		<button onclick='getCard()' id='guiTurnGetCard' disabled>&#10132; Vzít kartu</button> &nbsp; <span id='dragTarget'>&#8689;</span><br>
		<button onclick='doTableChange()' id='guiTurnChangeTable' disabled>&#10148; Provést změny</button>
	</div>
	<div id="help">
		<button onclick='document.getElementById("help").classList.toggle("visible")'>X</button>
		<h2>Nápověda</h2>
		<ul>
			<li>První hráč musí hru <b>založit</b> a další hráči se pak mohou ke hře <b>připojit</b>.</li> Pro to je třeba zadat <b>stejný kód hry</b>, zobrazený v levém sloupci, který musí zahajující hráč ostatním hráčům <b>předat</b>.</li>
			<li>Pro hru je potřeba se jako hráč <b>registrovat</b> pod zvoleným jménem.</li>
			<li>Jakmile je hra založena a registrován alespoň jeden hráč, je možno hru <b>zahájit</b>.</li>
			<li>Na tahu je vždy právě jeden hráč (ukazatel vlevo dole) a ostatní hráči nemají v té chvíli možnost provádět žádné akce.</li>
			<li>Během hry může hráč buď <b>vzít kartu</b> nebo, pokud vyložil některé karty z ruky na stůl, chtít <b>provést změny</b> na stole.</li>
			<li>Karty pro vytvoření nové sestavy je potřeba <b>označovat ve správném pořadí</b> zleva doprava (pokud se dokládá více karet najednou zleva, tak v opačném pořadí).</li>
			<li>Nová sestava na stole vznikne vždy při kliknutí na stůl. Jsou-li v tu chvíli již označeny některé karty, rovnou se do ní přidají.</li>
			<li>Dokládat označené karty k sestavám zleva nebo zprava lze kliknutím na prázdnou pozici vlevo nebo vpravo.</li>
			<li>Probliknutí obrazovky modře signalizuje úspěch tahu aktuálního hráče, naopak probliknutí červeně signalizuje neúspěch.</li>
			<li>Karty které jsou uskočeny směrem dolů jsou ty, které byly v minulém tahu změněny.</li>
			<li>Pokud se hráč dostane do stavu, kdy na stole udělal změny, které se nedají dokončit nebo se nedaří zvalidovat, může se vrátit na začátek svého tahu a <b>obnovit</b> jeho počáteční stav.</li>
			<li>Pokud hra skončí, zobrazí se výherci i všem hráčům upozornění. Novou hru je po skončení předchozí možno spustit znovu, již bez potřeby zadávání kódu.</li>
			<li>Pokud tlačítka <b>Vzít kartu</b> a <b>Provést změny</b> překáží nebo jsou na nevhodném místě, je možné je za šipku vedle nich přetáhnout na obrazovce na libovolné místo.</li>
			<li><b>klávesa A</b> = pokud chce hráč po vyložení své první validní sestavy měnit i sestavy již na stole, obojí v jediném tahu.</li>
			<li><b>klávesa S</b> = pokud jsou označeny právě dvě karty, např. žolík a karta namísto něj, provede se jejich výměna.</li>
		</ul>
	</div>

</body>
</html>

<!--
vyresit lepe zamky na fakt, ze nekdo muze chtit v jednom kole pripravit set a rovnou dokladat (poprve); da se podvadet preskladanim do nove groupy !!
lepe vyresit konec hry, omezit statusy?
umoznit na konci jeste dolozit sve karty_
4 z druhu jdou rozebrat i kdyz neni nahrada za jokera
vubec neposilat na validaci sestavy kratsi 3 karet
joker v ruce hlaska na GUI, mozna i jine
bude historie -2 dostatecna i pro hru vice hracu? asi ne, predelat na zasobnik podle poctu hracu + 1
kontrolovat v API konzistentne a vzdy ze je hra OK
pridat server side logovani chyb
zahajit hru vzetim karty?
vsechny zmeny, nejen nove karty na stole!!
doladit dalsi start hry, ted je dost rozbity
opravit vsechny php hinty
pridat nahodny GC na promazavani starych her
rozbita hra jednoho hrace
lepsi zvuky
-->
