<!doctype html>
<html lang="cs">
<head>
	<meta charset="utf-8">
	<title>Decomposed Joker GUI</title>
	<link rel="icon" type="image/png" href="favicon.ashx">
	<style>
		div#guiHand div div, div#guiNewSets div div, div#guiTable div div {width: 34px; display: inline-block; cursor: pointer;}
		div#guiPlayers div {width: 180px; display: inline-block;}
		div {border: 2px dotted gray; margin: 2px; padding: 3px;}
		div.active {border: 2px solid DarkGreen; filter: drop-shadow(2px 2px 6px DarkGreen);}
		div.spades {background-color: LightSteelBlue;}
		div.clubs {background-color: LightGray;}
		div.hearts {background-color: LightSalmon;}
		div.diamonds {background-color: LightCoral;}
		div.wildcard {background-color: Tan;}
		div#guiTable {column-count: 2; background-color: Ivory;}
		button {background-color: PaleGreen;}
	</style>
	<script>
		"use strict";

		// https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
		// Example POST method implementation:
		async function postData(data = {}) {
			// Default options are marked with *
			const response = await fetch('api.php', {
				method: 'POST', // *GET, POST, PUT, DELETE, etc.
				mode: 'cors', // no-cors, *cors, same-origin
				cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
				credentials: 'same-origin', // include, *same-origin, omit
				headers: {
					'Content-Type': 'application/json'
					// 'Content-Type': 'application/x-www-form-urlencoded',
				},
				redirect: 'follow', // manual, *follow, error
				referrerPolicy: 'no-referrer', // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url
				body: JSON.stringify(data) // body data type must match "Content-Type" header
			});
			const ret = await response.json(); // parses JSON response into native JavaScript objects
			console.dir('server call returned debug:', ret.dbg);
			if (response.status > 399) {
				throw "Server responded error with: " + ret.message;
			} else {
				return ret.data;
			}
		}

		var allCards = {};
		var playerId = '';
		var players = {};
		var hand = [];
		var sets = [];
		var table = [];
		var actives = [];
		var guiHand;
		var guiNewSets;
		var guiTable;
		var guiPlayers;

		async function initGame() {
			console.log('method: initGame');
			try {
				const deck = await postData({ action: 'initGame' });
				deck.forEach(c => window.allCards[c.id] = c);
				//console.dir('initGame', window.allCards);
			} catch (err) {
				console.dir('err', err);
			}

			initHelper();
		}

		async function joinGame() {
			console.log('method: joinGame');  // add ID later !!!
			try {
				const deck = await postData({ action: 'getGameCards' });
				deck.forEach(c => window.allCards[c.id] = c);
				//console.dir('initGame', window.allCards);
			} catch (err) {
				console.dir('err', err);
			}

			initHelper();
		}

		function initHelper() {
			console.log('method: initHeper');

			let hand = {};
			hand.id = 0; // 0 special setId and is always player's hand
			hand.cards = [];
			window.hand.push(hand);

			window.guiHand = document.getElementById('guiHand');
			window.guiHand.innerHTML = '';
			window.guiNewSets = document.getElementById('guiNewSets');
			window.guiNewSets.innerHTML = '';			
			window.guiTable = document.getElementById('guiTable');
			window.guiTable.innerHTML = '';
			window.guiPlayers = document.getElementById('guiPlayers');
			window.guiPlayers.innerHTML = '';

			createEmptySet();
		}

		async function registerPlayer(name) {
			console.log('method: registerPlayer', name);
			try {
				window.playerId = await postData({ action: 'registerPlayer', 'name': name });
				console.dir('registerPlayer', window.playerId);
			} catch (err) {
				console.dir('err', err);
			}
			let nm = el('span', null, ': ' + name);
			document.getElementById('indicator').appendChild(nm);
		}

		async function startGame() {
			console.log('method: startGame', window.playerId);
			try {
				if (await postData({ action: 'setActivePlayer', 'playerId': window.playerId })) {
					console.dir('startGame', true);
					await getPlayers(true);
				} else {
					throw 'Setting player as active failed';
				}
			} catch (err) {
				console.dir('err', err);
			}
			//getPlayers(); // should not be necessary later
		}

		async function getPlayers(render = false) {
			console.log('method: getPlayers');
			try {
				const plrs = await postData({ action: 'getPlayers' });
				window.players = plrs.players;
				console.dir('getPlayers', window.players);
			} catch (err) {
				console.dir('err', err);
			}
			if (render) {
				renderPlayers(true);
			}
		}

		async function getHand(render = false) {
			console.log('method: getHand');
			try {
				window.hand[0].cards = await postData({ action: 'getHand', 'playerId': window.playerId });
				console.dir('getHand', window.hand);
			} catch (err) {
				console.dir('err', err);
			}
			if (render) {
				renderCardGroups(window.hand, guiHand);
			}
		}

		async function getCard(render = false) {
			console.log('method: getCard');
			try {
				window.hand[0].cards = await postData({ action: 'getCard', 'playerId': window.playerId });
				console.dir('getCard', window.hand);
			} catch (err) {
				console.dir('err', err);
			}
			if (render) {
				renderCardGroups(window.hand, guiHand);
			}
			await getPlayers(true);
			showTurnEnd();
		}

		async function getTable(render = false) {
			console.log('method: getTable');
			try {
				const tbl = await postData({ action: 'getTable', 'playerId': window.playerId });
				window.table = [];
				tbl.forEach( grp => {
					let set = {};
					set.id = "s" + Math.random().toString(12).substring(2, 8);
					set.cards = grp;
					window.table.push(set);
				});
				console.dir('getTable', window.table);
			} catch (err) {
				console.dir('err', err);
			}
			if (render) {
				renderCardGroups(window.table, guiTable);
			}
		}

		async function getServerState() {
			console.log('method: getServerState');
			await getHand(true);
			await getTable(true);
			await getPlayers(true);
			window.actives = [];
			window.sets = [];
			createEmptySet();
			renderCardGroups(window.sets, guiNewSets);
		}

		async function validateAndDoTurn() {
			console.log('method: validateAndDoTurn');
			try {
				let newTbl = [];
				for(const s in window.table) {
					newTbl.push(window.table[s]);
				}
				for(const s in window.sets) {
					newTbl.push(window.sets[s]);
				}
				console.dir('trying to do tableChange...', newTbl);
				window.table = newTbl;
				await doTableChange();
			} catch (err) {
				console.dir('err', err);
			}
		}

		async function validateGroup(group) {
			console.log('method: validateGroup', group);
			try {
				const grp = await postData({ action: 'validateGroup', 'cards': group });
				console.dir('validateGroup', grp);
				return grp;
			} catch (err) {
				console.dir('err', err);
				return false;
			}
		}

		async function doTableChange() {
			console.log('method: doTableChange');
			try {
				let handCards = [];
				window.hand[0].cards.forEach( c => handCards.push({id: c, type: window.allCards[c].type, value: window.allCards[c].value}) );

				let fullTable = [];
				for(const s in window.table) {
					console.log('group_id...', s);
					let cardSet = [];
					window.table[s].cards.forEach( c => cardSet.push({id: c, type: window.allCards[c].type, value: window.allCards[c].value}) );
					if(cardSet.length) { // do not send empty sets by accident
						fullTable.push(cardSet);
					}
				}
				const turn = await postData({ action: 'doTableChange', 'playerId': window.playerId, 'table': fullTable, 'hand': handCards });
				console.dir('doTableChange', turn);
				// do all loading and rendering, table etc.... !!!!
				await getServerState();
				await getPlayers(true);
				showTurnEnd();
			} catch (err) {
				console.dir('err', err);
			}
		}


		// non server interactive functions

		function createEmptySet() {
			console.log('method: createEmptySet');
			let set = {};
			set.id = "s" + Math.random().toString(12).substring(2, 8);
			set.cards = [];
			console.dir(set);
			window.sets.push(set);
			renderCardGroups(window.sets, guiNewSets);
		}

		function renderCardGroups(groups, gui) {
			console.log('method: renderCardGroups', groups);
			gui.innerHTML = '';
			for(const s in groups) {
				console.log('rendering group_id', groups[s].id);
				const nl = el('div', groups[s].id, `id: ${groups[s].id}`);

				if (groups[s].id != 0) { // not for hand
					const butt0 = el('button', "act0-" + groups[s].id, '++X');
					butt0.addEventListener('click', (e) => addActiveCardsToSet(groups[s].id, true), true);
					nl.appendChild(butt0);
				}

				groups[s].cards.forEach( c => {
					const card = renderCard(c);
					card.addEventListener('click', (e) => activateCard(c), true);
					nl.appendChild(card);
				});

				if (groups[s].id !== 0) { // not for hand
					const butt = el('button', "act-" + groups[s].id, 'X++');
					butt.addEventListener('click', (e) => addActiveCardsToSet(groups[s].id), true);
					nl.appendChild(butt);
				}
				gui.appendChild(nl);
			}
		}

		function addActiveCardsToSet(setId, toTheStart = false) {
			console.log('method: addActiveCardsToSet', setId, toTheStart, window.actives, window.sets);

			if (toTheStart) {
				window.actives.reverse();
			}

			window.actives.forEach( a => {
				console.dir('iterating window.actives', a);
				// do hand adds and removes
				const y = window.hand[0].cards.indexOf(a);
				if (y > -1) {
					window.hand[0].cards.splice(y, 1);
				} else if (setId === 0) {
					toTheStart ? window.hand[0].cards.unshift(a) : window.hand[0].cards.push(a);
					// add sort!!
				}

				// do table groups adds and removes
				window.table.forEach( (grp, idx) => {
					const x = grp.cards.indexOf(a);
					if (x > -1) {
						window.table[idx].cards.splice(x, 1);
					} else if (setId === window.table[idx].id) {
						toTheStart ? window.table[idx].cards.unshift(a) : window.table[idx].cards.push(a);
						// add sort!!
					}
				});

				// do new sets adds and removes
				window.sets.forEach( (grp, idx) => {
					console.log('iterating via group', grp, idx);
					const z = grp.cards.indexOf(a);
					if (z > -1) {
						window.sets[idx].cards.splice(z, 1);
					} else if (setId === window.sets[idx].id) {
						toTheStart ? window.sets[idx].cards.unshift(a) : window.sets[idx].cards.push(a);
						// add sort!!
					}
				});
			});

			window.actives = [];
			renderCardGroups(window.sets, guiNewSets);
			renderCardGroups(window.hand, guiHand);
			renderCardGroups(window.table, guiTable);
		}

		function renderCard(id) {
			const m = {spades: '&spades;', hearts: '&hearts;', diamonds: '&diams;', clubs: '&clubs;', wildcard: '&#10029;', 1: 'A', 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 10: 10, 11: 'J', 12: 'Q', 13: 'K', 0: '&zeta;'};
			let card = el('div', id, `${m[window.allCards[id].value]} ${m[window.allCards[id].type]}`);
			card.classList.add(window.allCards[id].type, window.allCards[id].value);
			return card;
		}

		function renderPlayers() {
			window.guiPlayers.innerHTML = '';
			for(const p in window.players) {
				let plr = el('div', null, `${window.players[p].name} (${window.players[p].cards} cards)`);
				plr.classList.add(window.players[p].active);
				guiPlayers.appendChild(plr);
			}
		}

		function activateCard(id) {
			const x = window.actives.indexOf(id);
			if (x > -1) {
				window.actives.splice(x, 1);
			} else {
				window.actives.push(id)	
			}
			document.getElementById(id).classList.toggle("active");
			event.stopPropagation();
		}

		function el(element, id = null, htmlBody = '') {
			let el = document.createElement(element);
			el.innerHTML = htmlBody;
			if (id) {
				el.id = id;
			}
			return el;
		}

		function showTurnEnd() {
			document.getElementById("indicator").animate(
				[
					{ letterSpacing: '1px', color: '#000' },
					{ letterSpacing: '10px', color: '#0a0' },
					{ letterSpacing: '1px', color: '#000' }
				], 500);
		}
	</script>
</head>
<body>

<h3 id="indicator">Decomposed Joker GUI</h3>

<button onclick='initGame()'>Init Game</button>
<button onclick='joinGame()'>Join Game</button>
<button onclick='registerPlayer(prompt("Please enter your name", "Marek"))'>registerPlayer</button>
<button onclick='startGame()'>start game / set me as active player</button> 
<button onclick='getServerState()'>refresh / reset</button> 
<!--button onclick='getHand(true)'>getHand and renderHand</button>
<button onclick='getTable(true)'>getTable and renderTable</button--> ||  ||  || 
<button onclick='getCard(true)'>getCard and end turn</button>
<button onclick='validateAndDoTurn()'>validate all groups and end turn</button>
<hr>
Players:
<div id='guiPlayers'></div>
Hand:
<div id='guiHand'></div>
NewSets: <button onclick='createEmptySet()'>create Empty Set</button>
<div id='guiNewSets'></div>
Table
<div id='guiTable'></div>
<hr>

vyresit kam se ztraceji karty/proc nejsou v allCards ???



</body>
</html>
