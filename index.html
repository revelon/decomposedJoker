<!doctype html>
<html lang="cs" id="html">
<head>
	<meta charset="utf-8">
	<title>Decomposed Joker GUI</title>
	<link rel="icon" type="image/png" href="favicon.ashx">
	<style>
		html {background: radial-gradient(circle, rgb(166,221,129) 13%, rgb(37,152,53) 84%); height:100%; color: White; font-family: serif;}
		body {margin: 0px;}
		div#guiHand div div, div#guiNewSets div div, div#guiTable div div {width: 34px; height: 55px; display: inline-block; cursor: pointer; border: 1px solid Gray; margin-left: -8px; border-radius: 4px; user-select: none; break-inside: avoid;}
		div#guiHand, div#guiNewSets, div#guiTable {padding-left: 10px;}
		div#guiPlayers div {width: 180px; display: inline-block;}
		div#guiPlayers div.winner {color: gold; font-size: 2em;}
		div.active {border: 2px solid DarkGreen; filter: drop-shadow(-3px 3px 1px Black); background-color: LightCyan !important; color: Gray;}
		div.spades {background-color: White; color: Black;} 
		div.clubs {background-color: MistyRose; color: Black;}
		div.hearts {background-color: Cornsilk; color: Red;}
		div.diamonds {background-color: Ivory; color: Red;}
		div.wildcard {background-color: White; color: DarkOrange;}
		div#guiTable {column-count: 2;}
		button {background-color: Gold; font-size: 1em;}
		input {background-color: Pink; font-size: 1em; cursor: crosshair;}
		button#guiTurnGetCard, button#guiTurnChangeTable {
			font-size: 1.6em; background-color: Beige; position: fixed; right: 30px; filter: drop-shadow(2px 2px 12px Gold); border-radius: 8px;}
		button#guiTurnGetCard {bottom: 80px;}
		button#guiTurnChangeTable {bottom: 30px;}
		button {font-family: serif;}
		div#guiHand button:first-of-type, div#guiNewSets button:first-of-type, div#guiTable button:first-of-type {margin-right: 11px;}
		button.big {font-size: 2.5em;}

		.wrapper {
			display: grid;
    		grid-gap: 10px;
			grid-template-columns: repeat(4, [col] 24.5% );
			grid-template-rows: repeat(3, [row] auto );
		}

		.box {
			background-color: rgba(0,0,0,0.4);
			border-radius: 4px;
			padding: 4px;
			margin: 4px;
		}

		.a {
			grid-column: col / span 3;
			grid-row: row;
		}
		.b {
			grid-column: col 4;
			grid-row: row;
		}
		.c {
			grid-column: col / span 2;
			grid-row: row 2;
		}
		.d {
			grid-column: col 3 / span 2;
			grid-row: row 2;
		}
		.e {
			grid-column: col / span 4;
			grid-row: row 3;
		}

	</style>
	<script>
		"use strict";

		// https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
		// Example POST method implementation:
		async function postData(data = {}) {
			// Default options are marked with *
			const response = await fetch('api.php', {
				method: 'POST', // *GET, POST, PUT, DELETE, etc.
				mode: 'cors', // no-cors, *cors, same-origin
				cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
				credentials: 'same-origin', // include, *same-origin, omit
				headers: {
					'Content-Type': 'application/json'
					// 'Content-Type': 'application/x-www-form-urlencoded',
				},
				redirect: 'follow', // manual, *follow, error
				referrerPolicy: 'no-referrer', // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url
				body: JSON.stringify(data) // body data type must match "Content-Type" header
			});
			const ret = await response.json(); // parses JSON response into native JavaScript objects
			console.dir('server call returned debug:', ret.dbg);
			if (response.status > 399) {
				throw "Server responded error with: " + ret.message;
			} else {
				return ret.data;
			}
		}

		var allCards = {}; // all current game cards in the full deck
		var playerId = ''; // current player secret identifier
		var canModifyTable = false; // flag, if user already made one full set and can add cards to other sets
		var players = {}; // all players involved in current game
		var hand = []; // players card in hand
		var sets = []; // preparing, unfinished, unvalidated, new sets of cards (client side only)
		var table = []; // playing table with validated sets of cards (server side)
		var actives = []; // stack of currently selected cards (to create new set or append to existing one)
		var gameStatus = 'inactive'; // current game status: inactive | playing | finished
		var myTurn = false; // flag if it is this player's turn or not
		var tick; // holder for refresing/ticking setInterval object

		var guiHand;
		var guiNewSets;
		var guiTable;
		var guiPlayers;

		async function initGame() {
			console.log('method: initGame');
			try {
				const deck = await postData({ action: 'initGame' });
				deck.forEach(c => window.allCards[c.id] = c);
				//console.dir('initGame', window.allCards);
			} catch (err) {
				console.dir('err', err);
			}

			initHelper();
		}

		async function joinGame() {
			console.log('method: joinGame');  // add ID later !!!
			try {
				const deck = await postData({ action: 'getGameCards' });
				deck.forEach(c => window.allCards[c.id] = c);
				//console.dir('joinGame', window.allCards);
			} catch (err) {
				console.dir('err', err);
			}

			initHelper();
		}

		function initHelper() {
			console.log('method: initHeper');

			let hand = {};
			hand.id = 0; // 0 special setId and is always player's hand
			hand.cards = [];
			window.hand.push(hand);

			window.guiHand = document.getElementById('guiHand');
			window.guiHand.innerHTML = '';
			window.guiNewSets = document.getElementById('guiNewSets');
			window.guiNewSets.innerHTML = '';			
			window.guiTable = document.getElementById('guiTable');
			window.guiTable.innerHTML = '';
			window.guiPlayers = document.getElementById('guiPlayers');
			window.guiPlayers.innerHTML = '';

			document.getElementById('guiGameInit').setAttribute('disabled', true);
			document.getElementById('guiGameJoin').setAttribute('disabled', true);
			document.getElementById('guiRegPlayer').removeAttribute('disabled');

			createEmptySet();
			startAutoRefresh();
		}

		async function registerPlayer() {
			console.log('method: registerPlayer', window.localStorage.getItem('playerName'));
			const name = prompt("Please enter your name", window.localStorage.getItem('playerName'));
			if (name != window.localStorage.getItem('playerName')) {
				window.localStorage.setItem('playerName', name);
			}
			try {
				if (window.playerId = await postData({ action: 'registerPlayer', 'name': name })) {
					console.dir('registerPlayer', window.playerId);
					document.getElementById('guiRegPlayer').removeAttribute('disabled');
					let nm = el('span', null, ' &nbsp; &nbsp; &nbsp; (Player: ' + name + ')');
					document.getElementById('indicator').append(nm);
					document.getElementById('guiRegPlayer').setAttribute('disabled', true);
					document.getElementById('guiGameStart').removeAttribute('disabled');
				}
			} catch (err) {
				console.dir('err', err);
			}
		}

		async function startGame() {
			console.log('method: startGame', window.playerId);
			try {
				if (await postData({ action: 'setActivePlayer', 'playerId': window.playerId })) {
					console.dir('startGame', true);
					await getHand(true);
					window.gameStatus = 'playing';
					//window.myTurn = true;
					document.getElementById('guiGameStart').setAttribute('disabled', true);
					document.getElementById('guiTurnGetCard').removeAttribute('disabled');
					document.getElementById('guiTurnChangeTable').removeAttribute('disabled');
				} else {
					throw 'Setting player as active failed';
				}
			} catch (err) {
				console.dir('err', err);
			}
		}

		async function getGameInfo(render = false) {
			console.log('method: getGameInfo');
			if (!window.myTurn && !document.hidden) {
				document.getElementById('guiTurnGetCard').setAttribute('disabled', true);
				document.getElementById('guiTurnChangeTable').setAttribute('disabled', true);
				try {
					const p = await postData({ action: 'getGameInfo', 'playerId': window.playerId });
					// changed state?
					const change = (window.gameStatus != p.gameStatus || window.myTurn != p.amIActivePlayer) ? true : false;
					window.gameStatus = p.gameStatus;
					window.players = p.players;
					window.myTurn = p.amIActivePlayer;
					console.dir('players and gameStatus', window.players, window.gameStatus);
					if (render) {
						renderGameInfo(change);
					}
					if (window.gameStatus == 'finished') {
						startAutoRefresh(true);
						alert('Game Over');
					}
				} catch (err) {
					console.dir('err', err);
				}
			} else {
				document.getElementById('guiTurnGetCard').removeAttribute('disabled');
				document.getElementById('guiTurnChangeTable').removeAttribute('disabled');
			}
		}

		// let it run all the time
		function startAutoRefresh(forceReset = false) {
			console.log('method: autoRefresh');
			try {
				if (forceReset) {
					window.clearInterval(window.tick);
					return;
				}
				if (!window.tick) {
					window.tick = window.setInterval( async () => { await getGameInfo(true); }, 1000);
				} else {
					//window.clearInterval(window.tick);
				}
			} catch (err) {
				console.dir('err', err);
			}
		}

		async function getHand(render = false) {
			console.log('method: getHand');
			if (!window.playerId || !window.gameStatus == 'playing') {  // release a bit later
				return;
			}
			try {
				window.hand[0].cards = await postData({ action: 'getHand', 'playerId': window.playerId });
				console.dir('getHand', window.hand);
			} catch (err) {
				console.dir('err', err);
			}
			if (render) {
				renderCardGroups(window.hand, window.guiHand);
			}
		}

		async function getCard(render = false) {
			console.log('method: getCard');
			if (!window.gameStatus == 'playing') {
				return;
			}
			try {
				window.hand[0].cards = await postData({ action: 'getCard', 'playerId': window.playerId });
				console.dir('getCard', window.hand);
				window.myTurn = false;
			} catch (err) {
				console.dir('err', err);
			}
			if (render) {
				renderCardGroups(window.hand, window.guiHand);
			}
			showTurnEnd();
		}

		async function getTable(render = false) {
			console.log('method: getTable');
			if (!window.gameStatus == 'playing') {
				return;
			}
			try {
				const tbl = await postData({ action: 'getTable', 'playerId': window.playerId });
				window.table = [];
				tbl.forEach( grp => {
					let set = {};
					set.id = "s" + Math.random().toString(12).substring(2, 8);
					set.cards = grp;
					window.table.push(set);
				});
				console.dir('getTable', window.table);
			} catch (err) {
				console.dir('err', err);
			}
			if (render) {
				renderCardGroups(window.table, window.guiTable, window.canModifyTable);
			}
		}

		async function getServerState() {
			console.log('method: getServerState');
			await getHand(true);
			await getTable(true);
			window.actives = [];
			window.sets = [];
			createEmptySet();
			renderCardGroups(window.sets, window.guiNewSets);
		}

		async function validateGroup(group) {
			console.log('method: validateGroup', group);
			try {
				const grp = await postData({ action: 'validateGroup', 'cards': group });
				console.dir('validateGroup', grp);
				return grp;
			} catch (err) {
				console.dir('err', err);
				return false;
			}
		}

		async function doTableChange() {
			console.log('method: doTableChange');
			if (!window.gameStatus == 'playing' || !window.myTurn) {
				return;
			}
			// try to be user friendly and validate active cards as new set
			if (window.actives.length > 2 && window.sets.length == 1 && window.sets[0].cards.length == 0) {
				addActiveCardsToSet(window.sets[0].id);
			}

			try {
				let handCards = [];
				window.hand[0].cards.forEach( c => handCards.push({id: c, type: window.allCards[c].type, value: window.allCards[c].value}) );

				// merge prepared sets and xisting table to new table
				let newTbl = [];
				for(const s in window.table) {
					newTbl.push(window.table[s]);
				}
				for(const s in window.sets) {
					newTbl.push(window.sets[s]);
				}
				console.dir('trying to do tableChange as new table...', newTbl);
				window.table = newTbl;

				// and now try to do server side validation
				let fullTable = [];
				for(const s in window.table) {
					console.log('group_id on existing table...', s);
					let cardSet = [];
					window.table[s].cards.forEach( c => cardSet.push({id: c, type: window.allCards[c].type, value: window.allCards[c].value}) );
					if(cardSet.length) { // do not send empty sets by accident
						fullTable.push(cardSet);
					}
				}
				const turn = await postData({ action: 'doTableChange', 'playerId': window.playerId, 'table': fullTable, 'hand': handCards });
				console.dir('doTableChange ended as', turn);
				// do all loading and rendering, table etc.... !!!!
				await getServerState();
				showTurnEnd();
				window.canModifyTable = true;
				if (turn == "won") {
					await getGameInfo(true);
					alert('Victory!!');
					startAutoRefresh(true);
				} else {
					window.myTurn = false;
				}
			} catch (err) {
				console.dir('err', err);
			}
		}


		// non server interactive functions

		function createEmptySet() {
			console.log('method: createEmptySet');
			let set = {};
			set.id = "s" + Math.random().toString(12).substring(2, 8);
			set.cards = [];
			console.dir(set);
			window.sets.push(set);
			renderCardGroups(window.sets, window.guiNewSets);
		}

		function renderCardGroups(groups, gui, enableEvents = true) {
			console.log('method: renderCardGroups', groups);
			gui.innerHTML = '';
			for(const s in groups) {
				console.log('rendering group_id', groups[s].id);
				const nl = el('div', groups[s].id);

				groups[s].cards.forEach( c => { // add cards
					const card = renderCard(c);
					if (enableEvents) {
						card.addEventListener('click', (e) => activateCard(c), true);
					}
					nl.append(card);
				});

				if (enableEvents) {
					if (groups[s].id != 0 && groups[s].cards.length) { // not for hand
						const butt0 = el('button', "act0-" + groups[s].id, ' + ');
						butt0.addEventListener('click', (e) => addActiveCardsToSet(groups[s].id, true), true);
						nl.prepend(butt0);
					}

					if (groups[s].id !== 0) { // not for hand
						const butt = el('button', "act-" + groups[s].id, ' + ');
						butt.addEventListener('click', (e) => addActiveCardsToSet(groups[s].id), true);
						if (!groups[s].cards.length) {
							butt.classList.add('big');	
						}						
						nl.append(butt);
					}
				}

				gui.append(nl);
			}
		}

		function addActiveCardsToSet(setId, toTheStart = false) {
			console.log('method: addActiveCardsToSet', setId, toTheStart, window.actives, JSON.stringify(window.sets, null, 2), JSON.stringify(window.table, null, 2));
			if (!window.gameStatus == 'playing' || !window.myTurn) {
				return false;
			}

			// validate if there is not card in the actives from the target set, which is invalid (for the time being)
			try {
				window.actives.forEach( a => {
					window.table.forEach( (grp, idx) => {
						const x = grp.cards.indexOf(a);
						if ((x > -1) && (setId == grp.id)) {
							console.dir('invalid!!!');
							throw "Invalid card : set combination";
						}
					});
					window.sets.forEach( (grp, idx) => {
						const x = grp.cards.indexOf(a);
						if ((x > -1) && (setId == grp.id)) {
							console.dir('invalid!!!');
							throw "Invalid card : set combination";
						}
					});
				});
			} catch (err) {
				console.dir('validation fail', err);
				return false;	
			}

			console.dir('continue SET modification after passed validations');

			if (toTheStart) {
				window.actives.reverse();
			}

			window.actives.forEach( a => {
				console.dir('iterating window.actives', a);
				// do hand adds and removes
				const y = window.hand[0].cards.indexOf(a);
				if (y > -1) {
					window.hand[0].cards.splice(y, 1);
				} else if (setId === 0) {
					toTheStart ? window.hand[0].cards.unshift(a) : window.hand[0].cards.push(a);
					// add sort!!
				}

				// do table groups adds and removes
				window.table.forEach( (grp, idx) => {
					const x = grp.cards.indexOf(a);
					if (x > -1) {
						window.table[idx].cards.splice(x, 1);
					} else if (setId === window.table[idx].id) {
						toTheStart ? window.table[idx].cards.unshift(a) : window.table[idx].cards.push(a);
						// add sort!!
					}
				});

				// do new sets adds and removes
				window.sets.forEach( (grp, idx) => {
					console.log('iterating via group', grp, idx);
					const z = grp.cards.indexOf(a);
					if (z > -1) {
						window.sets[idx].cards.splice(z, 1);
					} else if (setId === window.sets[idx].id) {
						toTheStart ? window.sets[idx].cards.unshift(a) : window.sets[idx].cards.push(a);
						// add sort!!
					}
				});
			});

			window.actives = [];
			renderCardGroups(window.sets, window.guiNewSets);
			renderCardGroups(window.hand, window.guiHand);
			renderCardGroups(window.table, window.guiTable, window.canModifyTable);
		}

		function renderCard(id) {
			const m = {spades: '&spades;', hearts: '&hearts;', diamonds: '&diams;', clubs: '&clubs;', wildcard: '&#10029;', 1: 'A', 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 10: 10, 11: 'J', 12: 'Q', 13: 'K', 0: '*'};
			let card = el('div', id, `${m[window.allCards[id].value]}<br>&nbsp;&nbsp;${m[window.allCards[id].type]}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;${m[window.allCards[id].value]}`);
			card.classList.add(window.allCards[id].type, window.allCards[id].value);
			return card;
		}

		// and set action permissing, refactor later
		function renderGameInfo(refresh) {
			window.guiPlayers.innerHTML = '';
			for(const p in window.players) {
				let plr = el('div', null, `${window.players[p].name} (${window.players[p].cards} cards)`);
				plr.classList.add(window.players[p].status);
				guiPlayers.append(plr);
			}

			if (refresh) {
				if (window.gameStatus == 'playing') {
					document.getElementById('guiGameStart').setAttribute('disabled', true);
					document.getElementById('guiUndoRefresh').removeAttribute('disabled');
					document.getElementById('guiEmptySet').removeAttribute('disabled');
				}
				getServerState();
			}
		}

		function activateCard(id) {
			if (!window.gameStatus == 'playing' || !window.myTurn) {
				return;
			}			
			const x = window.actives.indexOf(id);
			if (x > -1) {
				window.actives.splice(x, 1);
			} else {
				window.actives.push(id)	
			}
			document.getElementById(id).classList.toggle("active");
			event.stopPropagation();
		}

		function el(element, id = null, htmlBody = '') {
			let el = document.createElement(element);
			el.innerHTML = htmlBody;
			if (id) {
				el.id = id;
			}
			return el;
		}

		function showTurnEnd() {
			document.getElementById("indicator").animate(
				[
					{ letterSpacing: '1px', color: '#000' },
					{ letterSpacing: '5px', color: '#0a0' },
					{ letterSpacing: '1px', color: '#000' }
				], 700);
			document.getElementById("html").animate(
				[
					{ background: 'radial-gradient(circle, rgb(166,221,129) 13%, rgb(37,152,53) 84%)' },
					{ background: 'Black' },
					{ background: 'radial-gradient(circle, rgb(166,221,129) 13%, rgb(37,152,53) 84%)' }
				], 700);
		}

	</script>
</head>
<body>

<div class="wrapper">
	<div class="box a">
		<img src="joker.svg" width="128" style="float: left">
		<h1 id="indicator">Decomposed Joker</h1>

		<button onclick='initGame()' id='guiGameInit'>Init Game</button>
		<button onclick='joinGame()' id='guiGameJoin'>Join Game</button>
		<button onclick='registerPlayer()' id='guiRegPlayer' disabled>Register Player</button>
		<button onclick='startGame()' id='guiGameStart' disabled>Start Game</button>
		<button onclick='getServerState()' id='guiUndoRefresh' disabled>Refresh (Undo)</button>

		<button onclick='getCard(true)' id='guiTurnGetCard' disabled>Get Card</button>
		<button onclick='doTableChange()' id='guiTurnChangeTable' disabled>Validate Changes</button>
	</div>

	<div class="box b">
		Players:
		<div id='guiPlayers'></div>
	</div>

	<div class="box c">
		Hand:
		<div id='guiHand'></div>
	</div>

	<div class="box d">
		NewSets: <button onclick='createEmptySet()' id='guiEmptySet' disabled title="Create Empty Set">+</button>
		<div id='guiNewSets'></div>
	</div>

	<div class="box e">
		Table
		<div id='guiTable'></div>

		<hr>
		vyresit lepe zamky na fakt, ze nekdo muze chtit v jednom kole pripravit set a rovnou dokladat (poprve)<br>
		lepe vyresit konec hry<br>
		ukazat jinak nove/pridane karty<br>
		3 sloupce a lepsi layout stranky, top tlacitka plovouci<br>
		lepsi podbarveni aktivni karty<br>
		umoznit na konci jeste dolozit sve karty<br>
		nepreblikavat 2x provedenou zmenu (zkusit)<br>
	</div>

</div>
</body>
</html>

